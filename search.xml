<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[bzoj4016(点分治)]]></title>
    <url>%2F2019%2F03%2F13%2Fbzoj4016-%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[题解:强行凑题….. 前面构造最短路树 然后后半部分模板点分统计贡献 这个最短路树要保证路径的字典序最小 那么我们可以跑出最短路 枚举边 看距离差值是否等于边权 然后连边 对于所有连边排序以后 做$dfs$建树 第二部分就直接考虑子树合并 维护每个深度下的最大距离 以及方案数 枚举统计贡献 复杂度 $O(mlogn+nlogn)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=1e5+10;const double eps=1e-8;#define ll long longusing namespace std;const ll inf=1e12;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int n,m,k;vector&lt;pii&gt;vec[MAXN];ll dis[MAXN],ans1;ll ans2;bool vis[MAXN];typedef struct Node&#123; int x,y,z;&#125;Node;Node Edge[MAXN];typedef struct node&#123; int v;ll d; friend bool operator&lt;(node aa,node bb)&#123; return aa.d&gt;bb.d; &#125;&#125;node;priority_queue&lt;node&gt;que;void dij(int s)&#123; inc(i,1,n)vis[i]=0,dis[i]=inf; dis[s]=0;que.push((node)&#123;s,0&#125;); while(!que.empty())&#123; node t=que.top();que.pop(); if(vis[t.v])continue; vis[t.v]=1; link(t.v)&#123; if(dis[j-&gt;t]&gt;dis[t.v]+j-&gt;v)&#123; dis[j-&gt;t]=dis[t.v]+j-&gt;v; que.push((node)&#123;j-&gt;t,dis[j-&gt;t]&#125;); &#125; &#125; &#125; for(int i=1;i&lt;=m;i++)&#123; int x=Edge[i].x;int y=Edge[i].y; if(dis[x]&gt;dis[y])swap(x,y); if(Edge[i].z==dis[y]-dis[x])vec[x].pb(mp(y,Edge[i].z)); &#125;&#125;void dfs(int x)&#123; vis[x]=1; for(int i=0;i&lt;vec[x].size();i++)&#123; if(vis[vec[x][i].first])continue; add(x,vec[x][i].first,vec[x][i].second); add(vec[x][i].first,x,vec[x][i].second); dfs(vec[x][i].first); &#125;&#125;int rt,sz[MAXN],maxx[MAXN],base;int key;void get_root(int x,int pre)&#123; sz[x]=1;maxx[x]=0; link(x)&#123; if(vis[j-&gt;t]||j-&gt;t==pre)continue; get_root(j-&gt;t,x); sz[x]+=sz[j-&gt;t];maxx[x]=max(maxx[x],sz[j-&gt;t]); &#125; maxx[x]=max(maxx[x],base-sz[x]); if(key&gt;maxx[x])rt=x,key=maxx[x];&#125;int c1[MAXN];ll MAxx[MAXN];int num[MAXN];int st[MAXN],St[MAXN],tot,tot1;void _dfs(int x,int pre)&#123; num[x]=num[pre]+1; if(num[x]&gt;k)return ; st[++tot]=x,St[++tot1]=x; link(x)&#123; if(vis[j-&gt;t]||j-&gt;t==pre)continue; dis[j-&gt;t]=dis[x]+j-&gt;v; _dfs(j-&gt;t,x); &#125;&#125;void solve(int x)&#123; vis[x]=1;tot1=0;c1[1]=1;MAxx[1]=0; link(x)&#123; if(vis[j-&gt;t])continue; tot=0;num[x]=1;dis[j-&gt;t]=j-&gt;v;_dfs(j-&gt;t,x); inc(i,1,tot)&#123; if(dis[st[i]]+MAxx[k+1-num[st[i]]]&gt;ans1)ans1=dis[st[i]]+MAxx[k+1-num[st[i]]],ans2=c1[k+1-num[st[i]]]; else if(dis[st[i]]+MAxx[k+1-num[st[i]]]==ans1)ans2+=c1[k+1-num[st[i]]]; &#125; inc(i,1,tot)&#123; if(MAxx[num[st[i]]]==dis[st[i]])c1[num[st[i]]]++; else if(MAxx[num[st[i]]]&lt;dis[st[i]])MAxx[num[st[i]]]=dis[st[i]],c1[num[st[i]]]=1; &#125; &#125; inc(i,1,tot1)MAxx[num[St[i]]]=-inf,c1[num[St[i]]]=0; c1[1]=0;MAxx[1]=-inf; link(x)&#123; if(vis[j-&gt;t])continue; base=sz[j-&gt;t];key=(1&lt;&lt;30);get_root(j-&gt;t,0); solve(rt); &#125;&#125;int main()&#123; n=read();m=read();k=read(); inc(i,0,n)MAxx[i]=-inf; int x,y,z; inc(i,1,m)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z),Edge[i]=(Node)&#123;x,y,z&#125;; dij(1); memset(h,0,sizeof(h));memset(e,0,sizeof(e));o=e; inc(i,1,n)vis[i]=dis[i]=0; inc(i,1,n)sort(vec[i].begin(),vec[i].end()); dfs(1); inc(i,1,n)vis[i]=0; key=(1&lt;&lt;30);base=n;get_root(1,0); solve(rt); printf("%lld %lld\n",ans1,ans2); return 0;&#125; 题目描述给一个包含$n$个点，$m$条边的无向连通图。从顶点$1$出发，往其余所有点分别走一次并返回。 往某一个点走时，选择总长度最短的路径走。若有多条长度最短的路径，则选择经过的顶点序列字典序最小的那条路径(如路径A为$1,32,11，$路径B为$1,3,2,11$，路径B字典序较小。注意是序列的字典序的最小，而非路径中节点编号相连的字符串字典序最小)。到达该点后按原路返回，然后往其他点走，直到所有点都走过。 可以知道，经过的边会构成一棵最短路径树。请问，在这棵最短路径树上，最长的包含K个点的简单路径长度为多长？长度为该最长长度的不同路径有多少条？ 这里的简单路径是指：对于一个点最多只经过一次的路径。不同路径是指路径两端端点至少有一个不同，点A到点B的路径和点B到点A视为同一条路径 Input第一行输入三个正整数$n,m，K$，表示有$n$个点$m$条边，要求的路径需要经过$K$个点。接下来输入$m$行，每行三个正整数$A_i,B_i,C_i(1&lt;=A_i,B_i&lt;=n,1&lt;=C_i&lt;=10000)$，表示$A_i$和$B_i$间有一条长度为$C_i$的边。数据保证输入的是连通的无向图。 Output输出一行两个整数，以一个空格隔开，第一个整数表示包含$K$个点的路径最长为多长，第二个整数表示这样的不同的最长路径有多少条。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj3697(点分治)]]></title>
    <url>%2F2019%2F03%2F12%2Fbzoj3697-%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[题解:这题稍微有点绕 如果我们仅仅只要查询一段路径的上$0/1$路径段的数量相等的话 直接做点分就行了 但是现在需要存在一个中间转折点 要这个点到两段的$0/1$路径的数量段同样相等 所以我们考虑每个点到重心节点的$0/1$数量段的差值 我们根据节点之前的祖先节点是否出现和其一样差值的节点将其分成两类 然后分类讨论下 若当前这点属于前面有相同祖先节点具有相同差值的情况 那么他能和其他不同子树上任意一类节点产生贡献 若属于后者 那么他只能和其他不同子树中的第一类节点产生贡献 然后注意下细节就$OK$了 时间复杂度 $O(nlogn)$ 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;#define ll long longusing namespace std;const int inf=1e9;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int n,key,rt,base;int sz[MAXN],maxx[MAXN];int dp1[MAXN&lt;&lt;1],dp2[MAXN&lt;&lt;1],dis[MAXN],Vis[MAXN&lt;&lt;2];bool vis[MAXN];ll ans;void get_root(int x,int pre)&#123; sz[x]=1;maxx[x]=0; link(x)&#123; if(j-&gt;t==pre||vis[j-&gt;t])continue; get_root(j-&gt;t,x); sz[x]+=sz[j-&gt;t];maxx[x]=max(maxx[x],sz[j-&gt;t]); &#125; maxx[x]=max(maxx[x],base-sz[x]); if(key&gt;maxx[x])key=maxx[x],rt=x;&#125;int tot,St[MAXN],tot1;pii st[MAXN];void dfs(int x,int pre)&#123; St[++tot1]=dis[x]; //cout&lt;&lt;x&lt;&lt;":: "&lt;&lt;pre&lt;&lt;" "&lt;&lt;dis[x]&lt;&lt;endl; if(Vis[dis[x]+n])ans+=dp1[n-dis[x]],ans+=dp2[n-dis[x]],st[++tot]=mp(dis[x],1); else ans+=dp2[n-dis[x]],st[++tot]=mp(dis[x],2); if(!dis[x]&amp;&amp;Vis[n])ans++; if(!dis[x]&amp;&amp;!Vis[n])ans+=dp1[n]; Vis[dis[x]+n]++; // cout&lt;&lt;x&lt;&lt;"::: "&lt;&lt;dis[x]&lt;&lt;" "&lt;&lt;ans&lt;&lt;endl; link(x)&#123; if(j-&gt;t==pre||vis[j-&gt;t])continue; dis[j-&gt;t]=dis[x]+(j-&gt;v==0?1:-1); dfs(j-&gt;t,x); &#125; Vis[dis[x]+n]--;&#125;void solve(int x)&#123; vis[x]=1;tot1=0; link(x)&#123; if(vis[j-&gt;t])continue; tot=0;dis[j-&gt;t]=(j-&gt;v==0?1:-1);dfs(j-&gt;t,x); inc(i,1,tot)if(st[i].second==1)dp2[n+st[i].first]++;else dp1[n+st[i].first]++; &#125; inc(i,1,tot1)dp1[n+St[i]]=dp2[n+St[i]]=0; link(x)&#123; if(vis[j-&gt;t])continue; key=inf;base=sz[j-&gt;t];get_root(j-&gt;t,0); solve(rt); &#125;&#125;int main()&#123; n=read(); int x,y,z; ans=0; inc(i,2,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); key=inf;base=n;get_root(1,0); solve(rt); printf("%lld\n",ans); return 0;&#125; 题目描述采药人的药田是一个树状结构，每条路径上都种植着同种药材。采药人以自己对药材独到的见解，对每种药材进行了分类。大致分为两类，一种是阴性的，一种是阳性的。采药人每天都要进行采药活动。他选择的路径是很有讲究的，他认为阴阳平衡是很重要的，所以他走的一定是两种药材数目相等的路径。采药工作是很辛苦的，所以他希望他选出的路径中有一个可以作为休息站的节点（不包括起点和终点），满足起点到休息站和休息站到终点的路径也是阴阳平衡的。他想知道他一共可以选择多少种不同的路径。 Input第$1$行包含一个整数$N$。接下来$N-1$行，每行包含三个整数$a_i b_i t_i$,表示这条路上药材的类型。 Output输出符合采药人要求的路径数目。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1316(点分治)]]></title>
    <url>%2F2019%2F03%2F12%2Fbzoj1316-%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[题解第一眼以为$q$很大…想了一晚上…. 然后早上起来看题….$q&lt;=100$ 惊了 好了 言归正传 $q&lt;=100$那就直接暴力跑100次点分$ check $ 据说这样会被卡常数???反正我没试过 我们考虑 直接在重心分治的时候$check$ 每次把新的子树合并上去 然后$q$次$check$对应的$len$是否存在 然后我很快就$WA$了 原因是因为 $len=0$ 这种情况存在 特判下就能A了 复杂度 $O(qnlogn)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const int NM=1e6+10;const double eps=1e-8;#define ll long longusing namespace std;const int inf=1e9;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int p[MAXN],q,n,key,rt,base;bool Num[NM],vis[MAXN],ans[MAXN];int sz[MAXN],maxx[MAXN];void get_root(int x,int pre)&#123; sz[x]=1;maxx[x]=0; link(x)&#123; if(j-&gt;t==pre||vis[j-&gt;t])continue; get_root(j-&gt;t,x); sz[x]+=sz[j-&gt;t];maxx[x]=max(maxx[x],sz[j-&gt;t]); &#125; maxx[x]=max(maxx[x],base-sz[x]); if(key&gt;maxx[x])rt=x,key=maxx[x];&#125;int st[MAXN],St[MAXN],tot,tot1;int dis[MAXN];void dfs(int x,int pre)&#123; if(dis[x]&lt;NM)st[++tot]=dis[x],St[++tot1]=dis[x]; link(x)&#123; if(j-&gt;t==pre||vis[j-&gt;t])continue; dis[j-&gt;t]=dis[x]+j-&gt;v; dfs(j-&gt;t,x); &#125;&#125;void solve(int x)&#123; tot1=0;Num[0]=1;vis[x]=1; link(x)&#123; if(vis[j-&gt;t])continue; tot=0;dis[j-&gt;t]=j-&gt;v;dfs(j-&gt;t,x); inc(i,1,tot)inc(k,1,q)if(st[i]&lt;=p[k]&amp;&amp;Num[p[k]-st[i]])ans[k]=1; inc(i,1,tot)Num[st[i]]=1; &#125; inc(i,1,tot1)Num[St[i]]=0;Num[0]=0; link(x)&#123; if(vis[j-&gt;t])continue; key=inf;base=sz[j-&gt;t];get_root(j-&gt;t,0); solve(rt); &#125;&#125;int main()&#123; inc(i,0,NM-1)Num[i]=0; n=read();q=read(); int x,y,z; inc(i,2,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); inc(i,1,q)p[i]=read(); key=inf;base=n;get_root(1,0); solve(rt); inc(i,1,q)if(!p[i]||ans[i])puts("Yes");else puts("No"); return 0;&#125; 题目描述一棵$n$个点的带权有根树，有$p$个询问，每次询问树中是否存在一条长度为$Len$的路径，如果是，输出$Yes$否输出$No$. Input第一行两个整数$n, p$分别表示点的个数和询问的个数． 接下来$n-1$行每行三个数$x, y, c$，表示有一条树边$x→y$，长度为$c$． 接下来$p$行每行一个数$Len$，表示询问树中是否存在一条长度为$Len$的路径． Output输出有$p$行，$Yes$或$No$.]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj2599(点分治)]]></title>
    <url>%2F2019%2F03%2F11%2Fbzoj2599-%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[题解讲个鬼故事~~ 第一次xjb写了一个点分治 统计贡献甚至没有去掉同颗子树的情况 骗了75分……..然后对拍写挂了 生成数据从1到n 对拍找不到错 …真是太菜了 言归正传: 对于统计贡献 我们可以把重心的儿子的子树一个个合并 然后维护答案就行了 坑点就是….别把$K$当做$N$ 然后注意别用$memset$来清空 直接用数组记录修改的位置 然后$for$循环清空就行了 注意还有不存在的情况需要处理 复杂度 $O(nlogn)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const int NM=1e6+10;const double eps=1e-8;#define ll long longconst int inf=1e9+7;using namespace std;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int n,K;bool vis[MAXN];ll dis[MAXN];int cnt[MAXN];int base,key,rt;int sz[MAXN],maxx[MAXN];void get_root(int x,int pre)&#123; sz[x]=1;maxx[x]=0; link(x)&#123; if(j-&gt;t==pre||vis[j-&gt;t])continue; get_root(j-&gt;t,x); sz[x]+=sz[j-&gt;t];maxx[x]=max(maxx[x],sz[j-&gt;t]); &#125; maxx[x]=max(maxx[x],base-sz[x]); if(key&gt;maxx[x])key=maxx[x],rt=x;&#125;int st[MAXN],tot,ans,St[MAXN],tot1;int num[NM],Num[NM];void dfs(int x,int pre)&#123; if(dis[x]&lt;=K)st[++tot]=dis[x],num[dis[x]]=min(num[dis[x]],cnt[x]),St[++tot1]=dis[x]; link(x)&#123; if(j-&gt;t==pre||vis[j-&gt;t])continue; dis[j-&gt;t]=dis[x]+j-&gt;v;cnt[j-&gt;t]=cnt[x]+1; dfs(j-&gt;t,x); &#125;&#125;void solve(int x)&#123; vis[x]=1;tot1=0;Num[0]=0; link(x)&#123; if(vis[j-&gt;t])continue; tot=0;dis[j-&gt;t]=j-&gt;v;cnt[j-&gt;t]=1;dfs(j-&gt;t,x); inc(i,1,tot)ans=min(ans,num[st[i]]+Num[K-st[i]]); inc(i,1,tot)Num[st[i]]=min(Num[st[i]],num[st[i]]),num[st[i]]=inf; &#125; inc(i,1,tot1)Num[St[i]]=inf; Num[0]=inf; link(x)&#123; if(vis[j-&gt;t])continue; key=inf;base=sz[j-&gt;t];get_root(j-&gt;t,0); solve(rt); &#125;&#125;int main()&#123; n=read();K=read(); int x,y,z; inc(i,1,K)num[i]=Num[i]=inf; inc(i,2,n)x=read()+1,y=read()+1,z=read(),add(x,y,z),add(y,x,z); ans=inf;key=inf;base=n;get_root(1,0); solve(rt); if(ans==inf)printf("-1\n"); else printf("%d\n",ans);&#125; 题目描述给一棵树,每条边有权.求一条简单路径,权值和等于$K$,且边的数量最小.$N &lt;= 200000$,$ K &lt;= 1000000$ Input第一行 两个整数 $n, k$第$二…….N$行 每行三个整数 表示一条无向边的两端和权值 (注意点的编号从0开始) Output一个整数 表示最小边数量 如果不存在这样的路径 输出$-1​$]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj2152(点分治)]]></title>
    <url>%2F2019%2F03%2F11%2Fbzoj2152-%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[题解点分治模板题 不同的是 我们不需要sort 也不需要去重 对于每个子树重心做一个树$dp$即可 $dp[x][y]$表示x的子树中到x距离模3后y的个数 然后对于每个子树重心 合并维护答案即可 $复杂度O(nlogn)$ 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;#define ll long longusing namespace std;const int inf=1e9;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int n;int base,key,pos,sz[MAXN],maxx[MAXN],rt;bool vis[MAXN];void get_root(int x,int pre)&#123; sz[x]=1;maxx[x]=0; link(x)&#123; if(vis[j-&gt;t]||j-&gt;t==pre)continue; get_root(j-&gt;t,x); sz[x]+=sz[j-&gt;t];maxx[x]=max(maxx[x],sz[j-&gt;t]); &#125; maxx[x]=max(maxx[x],base-sz[x]); if(key&gt;maxx[x])key=maxx[x],rt=x;&#125;int t[MAXN][4];ll dis[MAXN];void dfs(int x,int pre)&#123; t[x][0]=t[x][1]=t[x][2]=0; t[x][dis[x]%3]++; link(x)&#123; if(vis[j-&gt;t]||j-&gt;t==pre)continue; dis[j-&gt;t]=dis[x]+j-&gt;v; dfs(j-&gt;t,x); t[x][0]+=t[j-&gt;t][0];t[x][1]+=t[j-&gt;t][1];t[x][2]+=t[j-&gt;t][2]; &#125;&#125;ll ans;void solve(int x,int pre)&#123; vis[x]=1;dis[x]=0; dfs(x,0); t[x][0]=t[x][1]=t[x][2]=0;t[x][0]++; link(x)&#123; if(vis[j-&gt;t]||j-&gt;t==pre)continue; ans+=1ll*t[x][0]*t[j-&gt;t][0]; ans+=1ll*t[x][1]*t[j-&gt;t][2]; ans+=1ll*t[x][2]*t[j-&gt;t][1]; t[x][0]+=t[j-&gt;t][0];t[x][1]+=t[j-&gt;t][1];t[x][2]+=t[j-&gt;t][2]; &#125; link(x)&#123; if(vis[j-&gt;t]||j-&gt;t==pre)continue; key=inf;base=sz[j-&gt;t];get_root(j-&gt;t,x); solve(rt,0); &#125;&#125;int main()&#123; n=read(); int x,y,z; inc(i,2,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); ans=0; base=n;key=inf;get_root(1,0); solve(rt,0); ll t1=2*ans+n;ll t2=1ll*n*n; ll t=__gcd(t1,t2);t1/=t;t2/=t; printf("%lld/%lld\n",t1,t2); return 0;&#125; 题目描述聪聪和可可是兄弟俩，他们俩经常为了一些琐事打起来，例如家中只剩下最后一根冰棍而两人都想吃、两个人都想玩儿电脑（可是他们家只有一台电脑）……遇到这种问题，一般情况下石头剪刀布就好了，可是他们已经玩儿腻了这种低智商的游戏。他们的爸爸快被他们的争吵烦死了，所以他发明了一个新游戏：由爸爸在纸上画$n$个“点”，并用$n-1$条“边”把这$n$个“点”恰好连通（其实这就是一棵树）。并且每条“边”上都有一个数。接下来由聪聪和可可分别随即选一个点（当然他们选点时是看不到这棵树的），如果两个点之间所有边上数的和加起来恰好是$3$的倍数，则判聪聪赢，否则可可赢。聪聪非常爱思考问题，在每次游戏后都会仔细研究这棵树，希望知道对于这张图自己的获胜概率是多少。现请你帮忙求出这个值以验证聪聪的答案是否正确。 Input输入的第1行包含1个正整数$n$。后面$n-1$行，每行$3$个整数$x、y、w$，表示$x$号点和$y$号点之间有一条边，上面的数是$w$。 Output以即约分数形式输出这个概率（即$“a/b”$的形式，其中$a$和$b$必须互质。如果概率为$1$，输出$“1/1”$）。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj3365(点分治)]]></title>
    <url>%2F2019%2F03%2F11%2Fbzoj3365-%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[题解同上题 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;#define ll long longusing namespace std;const int inf=1e9;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int n,K;int rt,base,sz[MAXN],maxx[MAXN],key;bool vis[MAXN];ll ans;void get_root(int x,int pre)&#123; sz[x]=1;maxx[x]=0; link(x)&#123; if(j-&gt;t==pre||vis[j-&gt;t])continue; get_root(j-&gt;t,x); sz[x]+=sz[j-&gt;t];maxx[x]=max(maxx[x],sz[j-&gt;t]); &#125; maxx[x]=max(maxx[x],base-sz[x]); if(maxx[x]&lt;key)key=maxx[x],rt=x;&#125;ll st[MAXN],dis[MAXN];int tot,num[MAXN];void get_deep(int x,int pre)&#123; num[x]=1; if(!pre)st[++tot]=dis[x]; link(x)&#123; if(j-&gt;t==pre||vis[j-&gt;t])continue; dis[j-&gt;t]=dis[x]+j-&gt;v;st[++tot]=dis[j-&gt;t]; get_deep(j-&gt;t,x); num[x]+=num[j-&gt;t]; &#125;&#125;ll get_sum(int x,ll dist)&#123; dis[x]=dist;tot=0;get_deep(x,0); sort(st+1,st+tot+1); ll sum=0; inc(i,1,tot)&#123; int l=i+1;int r=tot;int ans1=0; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(st[i]+st[mid]&lt;=K)ans1=mid,l=mid+1; else r=mid-1; &#125; if(!ans1)continue; sum+=ans1-i; &#125; return sum;&#125;void solve(int x,int y)&#123; vis[x]=1;ans+=get_sum(x,0); link(x)&#123; if(j-&gt;t==y||vis[j-&gt;t])continue; key=inf;base=num[j-&gt;t];get_root(j-&gt;t,x);ans-=get_sum(j-&gt;t,j-&gt;v); solve(rt,x); &#125;&#125;int main()&#123; int x,y,z; char ch; n=read();int m=read(); inc(i,2,n)scanf("%d %d %d %c",&amp;x,&amp;y,&amp;z,&amp;ch),add(x,y,z),add(y,x,z); K=read(); key=inf;base=n;get_root(1,0); solve(rt,0); printf("%lld\n",ans);&#125; 题目描述https://www.lydsy.com/JudgeOnline/problem.php?id=3365]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1468(点分治)]]></title>
    <url>%2F2019%2F03%2F11%2Fbzoj1468-%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[题解点分治模板题 第一次写点分治 那就把我的心酸证明历程也记录下吧 首先:前置知识点 树的重心(当$x$为根时,其子树节点的$size$的最大值最小) 然后每次以子树重心分治 保证分治层数不超过$logn$层 证明: 我们假如其$size_u&gt;size/2$那么 我们必然可以往其$size$较大的子树节点继续选择 那么这个点就不在是重心 然后:考虑如何统计点对贡献 我们可以处理出当前子树节点到$rt$的距离 然后$sort$以后双指针/二分查询贡献 但是这样会把子树节点内的点对重复计数 所以每次需要去重一下 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;#define ll long longusing namespace std;const int inf=1e9;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int n,K;int rt,base,sz[MAXN],maxx[MAXN],key;bool vis[MAXN];ll ans;void get_root(int x,int pre)&#123; sz[x]=1;maxx[x]=0; link(x)&#123; if(j-&gt;t==pre||vis[j-&gt;t])continue; get_root(j-&gt;t,x); sz[x]+=sz[j-&gt;t];maxx[x]=max(maxx[x],sz[j-&gt;t]); &#125; maxx[x]=max(maxx[x],base-sz[x]); if(maxx[x]&lt;key)key=maxx[x],rt=x;&#125;ll st[MAXN],dis[MAXN];int tot,num[MAXN];void get_deep(int x,int pre)&#123; num[x]=1; if(!pre)st[++tot]=dis[x]; link(x)&#123; if(j-&gt;t==pre||vis[j-&gt;t])continue; dis[j-&gt;t]=dis[x]+j-&gt;v;st[++tot]=dis[j-&gt;t]; get_deep(j-&gt;t,x); num[x]+=num[j-&gt;t]; &#125;&#125;ll get_sum(int x,ll dist)&#123; dis[x]=dist;tot=0;get_deep(x,0); sort(st+1,st+tot+1); ll sum=0; inc(i,1,tot)&#123; int l=i+1;int r=tot;int ans1=0; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(st[i]+st[mid]&lt;=K)ans1=mid,l=mid+1; else r=mid-1; &#125; if(!ans1)continue; sum+=ans1-i; &#125; return sum;&#125;void solve(int x,int y)&#123; vis[x]=1;ans+=get_sum(x,0); link(x)&#123; if(j-&gt;t==y||vis[j-&gt;t])continue; key=inf;base=num[j-&gt;t];get_root(j-&gt;t,x);ans-=get_sum(j-&gt;t,j-&gt;v); solve(rt,x); &#125;&#125;int main()&#123; int x,y,z; n=read(); inc(i,2,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); K=read(); key=inf;base=n;get_root(1,0); solve(rt,0); printf("%lld\n",ans);&#125; 题目描述给你一棵$TREE$,以及这棵树上边的距离.问有多少对点它们两者间的距离小于等于$K$ Input$N(n&lt;=40000)$接下来$n-1$行边描述管道，按照题目中写的输入 接下来是$k$ Output一行，有多少对点之间的距离小于等于$k$]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj2282树形dp]]></title>
    <url>%2F2019%2F03%2F10%2Fbzoj2282-%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[题解首先路径的选择应该是直径的某一段区间…证明略(虽然我也是直观感受的) 然后我们考虑对直径上区间的选择 对于区间[l,r]的价值为$max(dis(直径左端点,l),max(dis(直径右端点,r),子区间上的价值))$ 当$l$保持不变,$r$增加时,区间价值单调不增加,所以我们应该对于每个左端点$l$,找到最大r满足条件 然后统计 然后对于子区间价值的维护 我们可以找到每个点到离其最近直径上点距离的最大值更新并维护直径上点的价值 然后因为我单调队列 写挂了 就直接用线段树查询区间最大值即可 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;#define ll long longusing namespace std;const int inf=1e9+10;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125; int n;int st[MAXN],tot,p[MAXN],dis[MAXN],s;bool vis[MAXN];queue&lt;int&gt;que;int bfs(int x)&#123; inc(i,1,n)dis[i]=vis[i]=0; vis[x]=1;que.push(x); while(!que.empty())&#123; int y=que.front();que.pop(); link(y)if(!vis[j-&gt;t])vis[j-&gt;t]=1,dis[j-&gt;t]=dis[y]+j-&gt;v,que.push(j-&gt;t); &#125; int pos=x; inc(i,1,n)if(dis[pos]&lt;dis[i])pos=i; return pos;&#125; int sum[MAXN],fa[MAXN],ans[MAXN],key[MAXN];void dfs(int x,int pre)&#123; fa[x]=pre; link(x)if(j-&gt;t!=pre)sum[j-&gt;t]=sum[x]+j-&gt;v,key[j-&gt;t]=j-&gt;v,dfs(j-&gt;t,x);&#125; void _dfs(int x,int y)&#123; int k; if(vis[x])k=x;else k=y; p[x]=k; link(x)if(j-&gt;t!=fa[x])_dfs(j-&gt;t,k);&#125; int maxx[MAXN&lt;&lt;2],R[MAXN];void built(int x,int l,int r)&#123; if(l==r)&#123;maxx[x]=ans[st[l]];return ;&#125; int mid=(l+r)&gt;&gt;1; built(x&lt;&lt;1,l,mid); built(x&lt;&lt;1|1,mid+1,r); maxx[x]=max(maxx[x&lt;&lt;1],maxx[x&lt;&lt;1|1]);&#125; int Maxx;void query(int x,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;Maxx=max(Maxx,maxx[x]);return ;&#125; int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid)query(x&lt;&lt;1,l,mid,ql,qr); if(qr&gt;mid)query(x&lt;&lt;1|1,mid+1,r,ql,qr);&#125; int main()&#123; n=read();s=read(); int x,y,z; inc(i,2,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); x=bfs(1);y=bfs(x); dfs(x,0);tot=0; inc(i,1,n)vis[i]=0; int k1=y; while(y)st[++tot]=y,vis[y]=1,y=fa[y]; y=k1; _dfs(x,x); inc(i,1,n)ans[p[i]]=max(ans[p[i]],sum[i]-sum[p[i]]); built(1,1,tot); inc(i,1,tot)R[i]=R[i-1]+key[st[i]]; int ans2=inf; // cout&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;endl; inc(i,1,tot)&#123; int l=i;int r=tot;int ans1=0; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(R[mid]-R[i-1]&lt;=s)ans1=mid,l=mid+1; else r=mid-1; &#125; if(!ans1)ans1=i;else ans1=min(tot,ans1+1);// cout&lt;&lt;i&lt;&lt;"::: "&lt;&lt;ans1&lt;&lt;endl; Maxx=0;query(1,1,tot,i,ans1); ans2=min(ans2,max(Maxx,max(sum[y]-sum[st[i]],sum[st[ans1]]-sum[x]))); &#125; printf("%d\n",ans2); return 0; &#125; 题目描述某个国家有$n$个城市，这$n$个城市中任意两个都连通且有唯一一条路径，每条连通两个城市的道路的长度为$z_i(z_i&lt;=1000)$。 这个国家的人对火焰有超越宇宙的热情，所以这个国家最兴旺的行业是消防业。由于政府对国民的热情忍无可忍（大量的消防经费开销）可是却又无可奈何（总统竞选的国民支持率），所以只能想尽方法提高消防能力。 现在这个国家的经费足以在一条边长度和不超过$s$的路径（两端都是城市）上建立消防枢纽，为了尽量提高枢纽的利用率，要求其他所有城市到这条路径的距离的最大值最小。 你受命监管这个项目，你当然需要知道应该把枢纽建立在什么位置上。 Input输入包含$n$行：第$1$行，两个正整数$n$和$s$，中间用一个空格隔开。其中$n$为城市的个数,$s$为路径长度的上界。设结点编号以此为$1，2，……，n$。从第$2$行到第$n$行，每行给出$3$个用空格隔开的正整数，依次表示每一条边的两个端点编号和长度。例如，$“2 4 7”$表示连接结点$2$与$4$的边的长度为$7$。 Output输出包含一个非负整数，即所有城市到选择的路径的最大值，当然这个最大值必须是所有方案中最小的。]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1509(树形dp)]]></title>
    <url>%2F2019%2F03%2F10%2Fbzoj1509-%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[题解从一棵树里面找三个点$x,y,z$,从点$x$出发,先到另外两个点中离$x$较近的点,然后再到剩下那个点的路径和最大.首先对于直径两端点是必然选择,然后枚举起点,统计答案即可 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,long long&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;#define ll long longusing namespace std;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int n,m;ll dis[MAXN];bool vis[MAXN];queue&lt;int&gt;que;pii bfs(int x)&#123; inc(i,1,n)dis[i]=vis[i]=0; que.push(x);vis[x]=1; while(!que.empty())&#123; int y=que.front();que.pop(); link(y)&#123; if(!vis[j-&gt;t])vis[j-&gt;t]=1,dis[j-&gt;t]=dis[y]+j-&gt;v,que.push(j-&gt;t); &#125; &#125; pii pos=mp(x,0); inc(i,1,n)if(dis[pos.first]&lt;dis[i])pos=mp(i,dis[i]); return pos;&#125;int fa[MAXN];void dfs(int x,int pre)&#123; fa[x]=pre; link(x)if(j-&gt;t!=pre)dfs(j-&gt;t,x);&#125;int p[MAXN];ll sum[MAXN];void _dfs(int x,int y)&#123; int k; if(vis[x])k=x;else k=y; p[x]=k; link(x)if(j-&gt;t!=fa[x])sum[j-&gt;t]=sum[x]+j-&gt;v,_dfs(j-&gt;t,k);&#125;int main()&#123; n=read();m=read(); int x,y,z; inc(i,2,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); pii t1=bfs(1); pii t2=bfs(t1.first); ll ans=t2.second; dfs(t1.first,0);x=t2.first; inc(i,1,n)vis[i]=0; while(x)&#123;vis[x]=1;x=fa[x];&#125; _dfs(t1.first,t1.first); ll maxx=0; inc(i,1,n)maxx=max(maxx,sum[i]-sum[p[i]]+min(sum[p[i]]-sum[t1.first],sum[t2.first]-sum[p[i]])); printf("%lld\n",maxx+ans);&#125; 题目描述https://www.lydsy.com/JudgeOnline/problem.php?id=1509 Input第一行是两个整数$N(3&lt;=N&lt;=200000),M$,分别表示居住点总数和街道总数,以下$M$行，每行给出一条街道的信息。第$i+1$行包含整数$Ui、Vi、Ti（1&lt;=U_i, V_i &lt;= N，1 &lt;= T_i&lt;=1000000000)$，表示街道$i$连接居住点$U_i$和$V_i$，并且经过街道$i$需花费$T_i$分钟。街道信息不会重复给出。 Output仅包含整数$T$，即最坏情况下Chris的父母需要花费$T$分钟才能找到Chris。]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1912(树形dp)]]></title>
    <url>%2F2019%2F03%2F10%2Fbzoj1912-%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[题解 $ k=1 $ 必然连接直径两端 我们考虑$ k=2 $的情况 首先明确选的两条路径 选直径是否还是最优的?当然,不管如何考虑选直径带来的优势要大于不选直径 然后对于第二条路的选择 如果第二条路和直径有交边 那么交边还是会经过两次 那么就是让 两条路径并起来的部分减去交的部分长度最长 我们可以考虑将选出来的直径的边权置$-1$ 然后再求一遍树的直径 这样子就必然能得到最优解 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;#define ll long longusing namespace std;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int t)&#123;o-&gt;t=y;o-&gt;v=t;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125; int n,k;bool vis[MAXN];int dis[MAXN];queue&lt;int&gt;que;pii bfs(int x)&#123; inc(i,1,n)vis[i]=dis[i]=0; que.push(x);vis[x]=1; while(!que.empty())&#123; int y=que.front();que.pop(); link(y)&#123; if(!vis[j-&gt;t])vis[j-&gt;t]=1,dis[j-&gt;t]=dis[y]+j-&gt;v,que.push(j-&gt;t); &#125; &#125; pii pos=mp(x,0); inc(i,1,n)if(dis[pos.first]&lt;dis[i])pos=mp(i,dis[i]); return pos;&#125; int fa[MAXN]; void dfs(int x,int pre)&#123; fa[x]=pre; link(x)&#123; if(j-&gt;t==pre)continue; dfs(j-&gt;t,x); &#125;&#125; void _dfs(int x,int pre)&#123; link(x)&#123; if(j-&gt;t==pre)&#123;continue;&#125; if(vis[j-&gt;t])j-&gt;v=-1,_dfs(j-&gt;t,x); &#125;&#125; int dp[MAXN],dp1[MAXN];int st[MAXN],tot;bool cmp(int x,int y)&#123;return x&gt;y;&#125; void __dfs(int x,int pre)&#123; link(x)&#123; if(j-&gt;t==pre)continue; __dfs(j-&gt;t,x); dp[x]=max(dp[x],dp[j-&gt;t]); &#125; tot=0; link(x)&#123; if(j-&gt;t==pre)continue; st[++tot]=dp1[j-&gt;t]+j-&gt;v; &#125; sort(st+1,st+tot+1,cmp); // cout&lt;&lt;x&lt;&lt;"::: "&lt;&lt;tot&lt;&lt;" "&lt;&lt;st[1]&lt;&lt;endl; if(tot==0)return ; else if(tot==1)dp[x]=max(dp[x],st[1]),dp1[x]=st[1]; else dp[x]=max(dp[x],max(st[1]+st[2],st[1])),dp1[x]=st[1]; // cout&lt;&lt;x&lt;&lt;"::: "&lt;&lt;dp[x]&lt;&lt;endl;&#125; int main()&#123; n=read();k=read(); int x,y; inc(i,2,n)x=read(),y=read(),add(x,y,1),add(y,x,1); int ans=2*(n-1); pii t1,t2; t1=bfs(1);t2=bfs(t1.first); ans-=t2.second-1; if(k==2)&#123; inc(i,1,n)vis[i]=0; x=t2.first;y=t1.first; dfs(y,0); while(x)&#123; vis[x]=1; x=fa[x]; &#125; _dfs(y,0);__dfs(y,0); ans-=dp[y]-1; &#125; printf("%d\n",ans); return 0;&#125; 题目描述https://www.lydsy.com/JudgeOnline/problem.php?id=1912 Input第一行包含两个整数$n$,$K(1 ≤ K ≤ 2)$.接下来$n – 1$行，每行两个整数 $a, b$,表示村庄$a$与$b$之间有一条道路$(1 ≤ a, b ≤ n)$。 Output输出一个整数，表示新建了$K$条道路后能达到的最小巡逻距离。]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj4987(树形dp)]]></title>
    <url>%2F2019%2F03%2F09%2Fbzoj4987-%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[题解首先,$\sum_{i=1}^{k-1} dis(a_i,a_{i+1})​$ 最小化 那么对于这$k​$个点的选择可见必然是一个连通子树 可以反证 如何统计价值呢?我们考虑对于一棵树如何遍历每个点让路径和最小 显然是 $ 2sum-len​$ 即2倍路径和减去直径 这样子我们可以设$dp[i][j][0/1/2]​$ 表示在$i​$的子树中选了$j​$个点的联通子树 且直径的三种形态下的最小值 转移留给读者思考 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e3+10;const double eps=1e-8;#define ll long longconst ll inf=2e9;using namespace std;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int n,m,sz[MAXN];ll dp[MAXN][MAXN][3];ll ans;int check(int x,int y)&#123; if(x==1&amp;&amp;y==1)return 1; else if(x==0&amp;&amp;y==1)return 1; return 2;&#125;void dfs(int x,int pre)&#123; sz[x]=1; link(x)&#123; if(j-&gt;t==pre)continue; dfs(j-&gt;t,x); dec(i,min(sz[x],m),1)inc(k,0,2)for(int r=1;r+i&lt;=m&amp;&amp;r&lt;=sz[j-&gt;t];r++)inc(p,0,2-k)&#123; dp[x][i+r][k+p]=min(dp[x][i+r][k+p],dp[j-&gt;t][r][p]+dp[x][i][k]+(j-&gt;v)*check(k,p)); &#125; sz[x]+=sz[j-&gt;t]; &#125; ans=min(ans,min(dp[x][m][1],dp[x][m][2]));&#125;int main()&#123; n=read();m=read(); int x,y,z; inc(i,2,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); inc(i,1,n)inc(j,0,m)dp[i][j][0]=dp[i][j][1]=dp[i][j][2]=inf; inc(i,1,n)dp[i][1][1]=dp[i][1][0]=0; ans=inf; dfs(1,0); printf("%lld\n",ans);&#125; 题目描述从前有棵树。找出$K$个点$A_1,A_2,…,A_k$。最小化$\sum_{i=1}^{k-1} dis(a_i,a_{i+1})$ 输入描述第一行两个正整数$n$,$k$,表示数的顶点数和需要选出的点个数。 接下来$n-1$行每行3个非负整数$x$,$y$,$z$，表示从存在一条从$x$到$y$权值为$z$的边 输出描述一行一个整数，表示最小的距离和。]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj3124(树形dp)]]></title>
    <url>%2F2019%2F03%2F09%2Fbzoj3124-%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[题解:我们考虑找出任意一条直径的两个端点$x$,$y$ 对直径上的节点打上标记 对于其他不在直径上的点$v$ 找到其离的最近的标记点$pos$ 我们考虑当前$dis[pos]-dis[x]$与$dis[y]-dis[pos]$的大小关系然后判断$v$是否为分叉直径上的节点 若是则对原标记节点打上标记 最后的答案则为 每条边的权值是否等于分叉直径的条数 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;#define ll long longusing namespace std;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125; ll dis[MAXN];int n;bool vis[MAXN];queue&lt;int&gt;que;int bfs(int x)&#123; inc(i,1,n)vis[i]=dis[i]=0; que.push(x);vis[x]=1; while(!que.empty())&#123; int y=que.front();que.pop(); link(y)&#123; if(!vis[j-&gt;t])dis[j-&gt;t]=dis[y]+j-&gt;v,vis[j-&gt;t]=1,que.push(j-&gt;t); &#125; &#125; int pos=x; inc(i,1,n)&#123; if(dis[i]&gt;dis[pos])pos=i; &#125; return pos;&#125; int fa[MAXN],p[MAXN];ll sum[MAXN]; void dfs(int x,int pre)&#123; fa[x]=pre; link(x)&#123; if(j-&gt;t==pre)continue; sum[j-&gt;t]=sum[x]+j-&gt;v; dfs(j-&gt;t,x); &#125;&#125; void work(int y)&#123; inc(i,1,n)vis[i]=0; while(y)&#123; vis[y]=1;y=fa[y]; &#125;&#125; void _dfs(int x,int y)&#123; int k; if(vis[x])k=x;else k=y; p[x]=k; link(x)&#123; if(j-&gt;t==fa[x])continue; _dfs(j-&gt;t,k); &#125;&#125; int ans[MAXN]; void __dfs(int x)&#123; link(x)&#123; if(j-&gt;t==fa[x])continue; __dfs(j-&gt;t); ans[x]+=ans[j-&gt;t]; &#125;&#125; int main()&#123; n=read(); int x,y,z; inc(i,2,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); x=bfs(1);y=bfs(x); dfs(x,0);work(y);_dfs(x,x); ll len=sum[y]-sum[x]; printf("%lld\n",sum[y]-sum[x]); int cnt=0; inc(i,1,n)&#123; if(vis[i])continue; ll t1=sum[i]-sum[p[i]]; if(sum[p[i]]-sum[x]&gt;sum[y]-sum[p[i]])&#123; if(sum[p[i]]-sum[x]+t1==len)ans[p[i]]++,cnt++; &#125; else if(sum[p[i]]-sum[x]&lt;sum[y]-sum[p[i]])&#123; if(sum[y]-sum[p[i]]+t1==len)ans[y]++,ans[p[i]]--,cnt++; &#125; else&#123; if(t1==sum[p[i]]-sum[x])cnt++; &#125; &#125; __dfs(x); int ans1=0; inc(i,1,n)&#123; if(i==x||!vis[i])continue; if(ans[i]==cnt)ans1++; &#125; printf("%d\n",ans1);&#125; 题目描述小Q最近学习了一些图论知识。根据课本，有如下定义。树：无回路且连通的无向图，每条边都有正整数的权值来表示其长度。如果一棵树有$N$个节点，可以证明其有且仅有$N-1$条边。 路径：一棵树上，任意两个节点之间最多有一条简单路径。我们用$dis(a,b)$表示点$a$和点$b$的路径上各边长度之和。称$dis(a,b)$为$a$ ,$b$两个节点间的距离。直径：一棵树上，最长的路径为树的直径。树的直径可能不是唯一的。现在小Q想知道，对于给定的一棵树，其直径的长度是多少，以及有多少条边满足所有的直径都经过该边。 输入描述第一行包含一个整数$N$，表示节点数。接下来$N-1$行，每行三个整数$a$,$ b$,$ c$ ,表示点 $a$和点$b$之间有一条长度为$c$的无向边。 输出描述共两行。第一行一个整数，表示直径的长度。第二行一个整数，表示被所有直径经过的边的数量。]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
</search>
