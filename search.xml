<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[bzoj3124(树形dp)]]></title>
    <url>%2F2019%2F03%2F09%2Fbzoj3124-%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[题解:我们考虑找出任意一条直径的两个端点$x$,$y$ 对直径上的节点打上标记 对于其他不在直径上的点$v$ 找到其离的最近的标记点$pos$ 我们考虑当前$dis[pos]-dis[x]$与$dis[y]-dis[pos]$的大小关系然后判断$v​$是否为分叉直径上的节点 若是则对原标记节点打上标记 最后的答案则为 每条边的权值是否等于分叉直径的条数 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;#define ll long longusing namespace std;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125; ll dis[MAXN];int n;bool vis[MAXN];queue&lt;int&gt;que;int bfs(int x)&#123; inc(i,1,n)vis[i]=dis[i]=0; que.push(x);vis[x]=1; while(!que.empty())&#123; int y=que.front();que.pop(); link(y)&#123; if(!vis[j-&gt;t])dis[j-&gt;t]=dis[y]+j-&gt;v,vis[j-&gt;t]=1,que.push(j-&gt;t); &#125; &#125; int pos=x; inc(i,1,n)&#123; if(dis[i]&gt;dis[pos])pos=i; &#125; return pos;&#125; int fa[MAXN],p[MAXN];ll sum[MAXN]; void dfs(int x,int pre)&#123; fa[x]=pre; link(x)&#123; if(j-&gt;t==pre)continue; sum[j-&gt;t]=sum[x]+j-&gt;v; dfs(j-&gt;t,x); &#125;&#125; void work(int y)&#123; inc(i,1,n)vis[i]=0; while(y)&#123; vis[y]=1;y=fa[y]; &#125;&#125; void _dfs(int x,int y)&#123; int k; if(vis[x])k=x;else k=y; p[x]=k; link(x)&#123; if(j-&gt;t==fa[x])continue; _dfs(j-&gt;t,k); &#125;&#125; int ans[MAXN]; void __dfs(int x)&#123; link(x)&#123; if(j-&gt;t==fa[x])continue; __dfs(j-&gt;t); ans[x]+=ans[j-&gt;t]; &#125;&#125; int main()&#123; n=read(); int x,y,z; inc(i,2,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); x=bfs(1);y=bfs(x); dfs(x,0);work(y);_dfs(x,x); ll len=sum[y]-sum[x]; printf("%lld\n",sum[y]-sum[x]); int cnt=0; inc(i,1,n)&#123; if(vis[i])continue; ll t1=sum[i]-sum[p[i]]; if(sum[p[i]]-sum[x]&gt;sum[y]-sum[p[i]])&#123; if(sum[p[i]]-sum[x]+t1==len)ans[p[i]]++,cnt++; &#125; else if(sum[p[i]]-sum[x]&lt;sum[y]-sum[p[i]])&#123; if(sum[y]-sum[p[i]]+t1==len)ans[y]++,ans[p[i]]--,cnt++; &#125; else&#123; if(t1==sum[p[i]]-sum[x])cnt++; &#125; &#125; __dfs(x); int ans1=0; inc(i,1,n)&#123; if(i==x||!vis[i])continue; if(ans[i]==cnt)ans1++; &#125; printf("%d\n",ans1);&#125; 题目描述小Q最近学习了一些图论知识。根据课本，有如下定义。树：无回路且连通的无向图，每条边都有正整数的权值来表示其长度。如果一棵树有$N$个节点，可以证明其有且仅有$N-1$条边。 路径：一棵树上，任意两个节点之间最多有一条简单路径。我们用$dis(a,b)$表示点$a$和点$b$的路径上各边长度之和。称$dis(a,b)$为$a$ ,$b$两个节点间的距离。直径：一棵树上，最长的路径为树的直径。树的直径可能不是唯一的。现在小Q想知道，对于给定的一棵树，其直径的长度是多少，以及有多少条边满足所有的直径都经过该边。 输入描述第一行包含一个整数$N$，表示节点数。接下来$N-1$行，每行三个整数$a$,$ b$,$ c$ ,表示点 $a$和点$b$之间有一条长度为$c$的无向边。 输出描述共两行。第一行一个整数，表示直径的长度。第二行一个整数，表示被所有直径经过的边的数量。]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
</search>
