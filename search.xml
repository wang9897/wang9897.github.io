<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[仙人掌图的判定]]></title>
    <url>%2F2019%2F04%2F15%2F%E4%BB%99%E4%BA%BA%E6%8E%8C%E5%9B%BE%E7%9A%84%E5%88%A4%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[无向图上仙人掌图的判定例题洛谷P4129 通过$tarjan$ 求出所有的点双分量 根据仙人掌图的性质 我们对于包含非树边的点双分量 判断是否是简单环即可(通过判环的点数是否等于边数) 注意仙人掌图的前提 图是联通的 复杂度 $O(n+m)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183// 仙人掌是指无向连通图中,每一条边最多出现在一个简单环上#include &lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const int NM=1e6+10;const double eps=1e-8;const int mod=1e9+9;#define ll long longusing namespace std;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;struct Huge&#123; static const int MAXN=10001; static const int BASE=10000; int Num[MAXN]; int len; void init(const string &amp;s)&#123; memset(Num,0,sizeof(Num)); int rlen=s.size(); len=0; int i; for (i=rlen-5;i&gt;=0;i-=4)&#123; Num[len]=Num[len]*10+s[i+1]-'0'; Num[len]=Num[len]*10+s[i+2]-'0'; Num[len]=Num[len]*10+s[i+3]-'0'; Num[len]=Num[len]*10+s[i+4]-'0'; len++; &#125; if (i&lt;0) i+=4; for (int j=0;j&lt;=i;j++) Num[len]=Num[len]*10+s[j]-'0'; len++; &#125; friend istream&amp; operator&gt;&gt;(istream &amp;i, Huge &amp;v)&#123; string s; i&gt;&gt;s; v.init(s); return i; &#125; friend ostream&amp; operator&lt;&lt;(ostream &amp;o, Huge &amp;v)&#123; if (v.len==0 &amp;&amp; v.Num[0]==0)&#123; o&lt;&lt;'0'; return o; &#125; o&lt;&lt;v.Num[v.len-1]; for (int i=v.len-2;i&gt;=0;i--) o&lt;&lt;setw(4)&lt;&lt;setfill('0')&lt;&lt;v.Num[i]; return o; &#125; void operator+=(const Huge &amp;v) &#123; int nlen=max(v.len,len); for (int i=0;i&lt;nlen;i++)&#123; Num[i]+=v.Num[i]; if (Num[i]&gt;=BASE)&#123; Num[i]-=BASE; Num[i+1]++; &#125; &#125; if (Num[nlen]!=0) nlen++; len=nlen; //return (*this); &#125; void operator-=(const Huge &amp;v)&#123; int nlen=max(v.len,len); for (int i=0;i&lt;nlen;i++)&#123; Num[i]-=v.Num[i]; if (Num[i]&lt;0)&#123; Num[i]+=BASE; Num[i+1]--; &#125; &#125; while (Num[nlen]==0 &amp;&amp; nlen&gt;=0) nlen--; len=nlen+1; //return (*this); &#125; void operator*=(const Huge &amp;v)&#123; Huge c; c.init("0"); for (int i=0;i&lt;len;i++) for (int j=0;j&lt;v.len;j++)&#123; c.Num[i+j]+=Num[i]*v.Num[j]; if (c.Num[i+j]&gt;=BASE)&#123; c.Num[i+j+1]+=c.Num[i+j]/BASE; c.Num[i+j]%=BASE; &#125; &#125; c.len=len+v.len; while (c.Num[c.len]==0 &amp;&amp; c.len&gt;=0) c.len--; len=c.len+1; for (int i=0;i&lt;len;i++) Num[i]=c.Num[i]; //return (*this); &#125; bool operator&lt;(const Huge &amp;v)&#123; if (len!=v.len) return len&lt;v.len; for (int i=len-1;i&gt;=0;i--) if (Num[i]!=v.Num[i]) return Num[i]&lt;v.Num[i]; return 0; &#125;&#125;;int low[MAXN],dfn[MAXN],tarjan_bcc[MAXN];bool vis[MAXN],pis[NM];int Num[NM];vector&lt;int&gt;vec[NM];int st[NM],tot,cnt,num;typedef struct node&#123; int x,y;&#125;node;node d[NM];Huge ans,ans1;string trans(int x)&#123; string y; while(x)&#123; int t1=x%10;x-=t1;x/=10; y.push_back((char)(t1+'0')); &#125; reverse(y.begin(),y.end()); return y;&#125;void tarjan_Bcc(int x,int pre)&#123; vis[x]=1;low[x]=dfn[x]=++cnt; link(x)&#123; if(vis[j-&gt;t]&amp;&amp;dfn[j-&gt;t]&lt;dfn[x]&amp;&amp;j-&gt;t!=pre)&#123; st[++tot]=j-&gt;v;pis[j-&gt;v]=1; low[x]=min(low[x],dfn[j-&gt;t]); &#125; else if(!vis[j-&gt;t])&#123; st[++tot]=j-&gt;v; tarjan_Bcc(j-&gt;t,x); low[x]=min(low[x],low[j-&gt;t]); if(low[j-&gt;t]&gt;=dfn[x])&#123; num++;vec[num].clear(); while(1)&#123; int y=st[tot--]; if(pis[y])Num[num]++; if(tarjan_bcc[d[y].x]!=num)&#123; vec[num].pb(d[y].x); tarjan_bcc[d[y].x]=num; &#125; if(tarjan_bcc[d[y].y]!=num)&#123; vec[num].pb(d[y].y); tarjan_bcc[d[y].y]=num; &#125; if(j-&gt;v==y)break; &#125; if(Num[num]==1)ans1.init(trans(vec[num].size()+1)),ans*=ans1; &#125; &#125; &#125;&#125;int n,m;int main()&#123; int cnt1=0; n=read();m=read(); ans.init(trans(1)); inc(i,1,m)&#123; int k=read();int last=read(); inc(j,2,k)&#123; int x=read();cnt1++; d[cnt1].x=x;d[cnt1].y=last; add(x,last,cnt1); add(last,x,cnt1); last=x; &#125; &#125; int cnt2=0; inc(i,1,n)if(!vis[i])tarjan_Bcc(i,0),cnt2++; if(cnt2&gt;1)&#123;printf("0\n");return 0;&#125; inc(i,1,num)if(Num[i]&gt;1)&#123;printf("0\n");return 0;&#125; cout&lt;&lt;ans&lt;&lt;'\n'; return 0;&#125; 有向图上仙人掌图的判断例题hdu3594 参考博客仙人掌 首先我们通过$tarjan$ 判断图的强连通性 然后构造$dfs$树 通过分析 如果包含交叉边(两个端点不在同一个子树中) 前向边(出点是入点的祖先)则一定不满足仙人掌图 然后类似于树上差分的做法 判断一个边是否被多次覆盖即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126// 仙人掌是指无向连通图中,每一条边最多出现在一个简单环上#include &lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const int NM=1e6+10;const double eps=1e-8;const int mod=1e9+9;#define ll long longusing namespace std;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int dfn[MAXN],low[MAXN],tot;bool kis[MAXN],Kis[MAXN];stack&lt;int&gt;s;int Num;void tarjan_scc(int x)&#123; dfn[x]=low[x]=++tot; s.push(x);kis[x]=1; link(x)&#123; if(!dfn[j-&gt;t])&#123; tarjan_scc(j-&gt;t); low[x]=min(low[x],low[j-&gt;t]); &#125; else if(kis[j-&gt;t])&#123; low[x]=min(low[x],dfn[j-&gt;t]); &#125; &#125; if(low[x]==dfn[x])&#123; Num++;Kis[x]=1; while(1)&#123; int y=s.top(); if(y!=x)s.pop(),kis[y]=0,Kis[y]=1; else break; &#125; &#125;&#125;typedef struct node&#123; int x,y;&#125;node;node d[MAXN];int fa[MAXN],dep[MAXN],num[MAXN],son[MAXN];bool vis[MAXN],pis[NM];vector&lt;int&gt;vec[MAXN];int cnt,p[MAXN];void dfs(int x,int pre,int deep)&#123; fa[x]=pre;dep[x]=deep+1;num[x]=1;vis[x]=1; p[x]=++cnt; link(x)&#123; if(vis[j-&gt;t])continue; pis[j-&gt;v]=1;vec[x].pb(j-&gt;t); dfs(j-&gt;t,x,deep+1); num[x]+=num[j-&gt;t]; if(son[x]==-1||num[son[x]]&lt;num[j-&gt;t])son[x]=j-&gt;t; &#125;&#125;int tp[MAXN];void _dfs(int x,int td)&#123; tp[x]=td; if(son[x]!=-1)_dfs(son[x],td); for(int i=0;i&lt;vec[x].size();i++)if(vec[x][i]!=fa[x]&amp;&amp;vec[x][i]!=son[x])_dfs(vec[x][i],vec[x][i]);&#125;int Lca(int x,int y)&#123; int xx=tp[x];int yy=tp[y]; while(xx!=yy)&#123; if(dep[xx]&lt;dep[yy])swap(xx,yy),swap(x,y); x=fa[xx];xx=tp[x]; &#125; if(dep[x]&gt;dep[y])swap(x,y); return x;&#125;int sum[MAXN];void __dfs(int x,int pre)&#123; for(int i=0;i&lt;vec[x].size();i++)&#123; if(vec[x][i]==pre)continue; __dfs(vec[x][i],x); sum[x]+=sum[vec[x][i]]; &#125;&#125;int main()&#123; int _=read(); while(_--)&#123; int n=read();cnt=0; memset(h,0,sizeof(h));o=e; memset(Kis,0,sizeof(Kis)); memset(dfn,0,sizeof(dfn)); inc(i,1,n)sum[i]=vis[i]=0,vec[i].clear(),son[i]=-1; Num=tot=0; int x,y;int cnt1=0; while(~scanf("%d%d",&amp;x,&amp;y))&#123; if(!x&amp;&amp;!y)break; ++cnt1;d[cnt1].x=x+1;d[cnt1].y=y+1; add(x+1,y+1,cnt1); &#125; inc(i,1,n)if(!dfn[i])tarjan_scc(i); inc(i,1,cnt1)pis[i]=0; dfs(1,0,0); _dfs(1,1); bool flag=0; inc(i,1,cnt1)&#123; if(pis[i])continue; int lca=Lca(d[i].x,d[i].y); if(lca==d[i].x)&#123;flag=1;break;&#125; if(lca!=d[i].y)&#123;flag=1;break;&#125; sum[d[i].x]++;sum[d[i].y]--; &#125; inc(i,1,n)if(!Kis[i])&#123;flag=1;break;&#125; if(Num&gt;=2)&#123;flag=1;break;&#125; if(flag)&#123;printf("NO\n");continue;&#125; __dfs(1,0); inc(i,2,n)if(sum[i]&gt;1)&#123;printf("NO\n");flag=1;break;&#125; if(!flag)printf("YES\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>点双分量</tag>
        <tag>强联通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cf504E(树链剖分+SA)]]></title>
    <url>%2F2019%2F04%2F10%2Fcf504E-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86-SA%2F</url>
    <content type="text"><![CDATA[题意给你一颗$n$个节点的树 每个节点上都有一个字符$c$ q次查询两条路径形成的字符串的最长公共前缀 题解比较直观的做法是 树链剖分 每个点对对应$logn$个区间 然后二分答案 用$hash$取$check$ 复杂度$O(qlog^2n)$ 不能通过 我们考虑对两段路径的$logn$个区间 类似于区间合并的做法 转化成求两个重链上子区间的$lcp$ 那么我们将所有重链正反分别加入到字符串中 然后求一遍$SA$ 复杂度$O(nlogn+qlong)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=head[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=2e6+10;const double eps=1e-8;const int inf=1e9+9;#define ll long longusing namespace std;struct edge&#123;int t;edge*next;&#125;e[MAXN&lt;&lt;1],*head[MAXN],*o=e;void add(int x,int y)&#123;o-&gt;t=y;o-&gt;next=head[x];head[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int n;char str[MAXN];int fa[MAXN],dep[MAXN],son[MAXN],num[MAXN];void dfs(int x,int pre,int deep)&#123; fa[x]=pre;dep[x]=deep+1;num[x]=1; link(x)&#123; if(j-&gt;t==pre)continue; dfs(j-&gt;t,x,deep+1); num[x]+=num[j-&gt;t]; if(son[x]==-1||num[son[x]]&lt;num[j-&gt;t])son[x]=j-&gt;t; &#125;&#125;int p[MAXN],fp[MAXN],tp[MAXN],cnt;void _dfs(int x,int td)&#123; p[x]=++cnt;fp[p[x]]=x;tp[x]=td; if(son[x]!=-1)_dfs(son[x],td); link(x)if(j-&gt;t!=fa[x]&amp;&amp;j-&gt;t!=son[x])_dfs(j-&gt;t,j-&gt;t);&#125;char s[MAXN],s1[MAXN];int len,tot;int End[MAXN],Begin[MAXN];void work()&#123; len=0; inc(i,1,n)&#123; if(tp[i]!=i)continue; int t=i;tot=0;Begin[i]=len; while(t!=-1)&#123; s1[tot++]=str[t]; t=son[t]; &#125; inc(i,0,tot-1)s[len++]=s1[i]; s[len++]='$'; dec(i,tot-1,0)s[len++]=s1[i]; End[i]=len-1; s[len++]='$'; &#125; s[len]='\0';&#125;int sa[MAXN],txt[MAXN],t1[MAXN],t2[MAXN],rank1[MAXN],rank2[MAXN],Td[MAXN];bool cmp(int f[],int t,int w,int k)&#123;return f[t]==f[w]&amp;&amp;f[t+k]==f[w+k];&#125;void Sa()&#123; int m=256; int *rank1=t1;int *Td=t2; for(int i=0;i&lt;m;i++)txt[i]=0; for(int i=0;i&lt;len;i++)rank1[i]=s[i],txt[s[i]]++; for(int i=1;i&lt;=m;i++)txt[i]+=txt[i-1]; for(int i=len-1;i&gt;=0;i--)sa[--txt[s[i]]]=i; for(int k=1;k&lt;=len;k&lt;&lt;=1)&#123; int num=0; for(int i=len-k;i&lt;len;i++)Td[num++]=i; for(int i=0;i&lt;len;i++)if(sa[i]&gt;=k)Td[num++]=sa[i]-k; for(int i=0;i&lt;m;i++)txt[i]=0; for(int i=0;i&lt;len;i++)txt[rank1[i]]++; for(int i=1;i&lt;m;i++)txt[i]+=txt[i-1]; for(int i=len-1;i&gt;=0;i--)sa[--txt[rank1[Td[i]]]]=Td[i]; swap(rank1,Td);rank1[sa[0]]=0; num=1; for(int i=1;i&lt;len;i++)rank1[sa[i]]=cmp(Td,sa[i],sa[i-1],k)?num-1:num++; if(num&gt;=len)break; m=num; &#125; for(int i=0;i&lt;len;i++)rank2[sa[i]]=i;&#125;int h[MAXN],H[MAXN];void hh()&#123; for(int i=0;i&lt;len;i++)&#123; if(rank2[i]==0)continue; int t=sa[rank2[i]-1];int w=i;int k=0; if(i==0||H[i-1]&lt;=1)k=0;else k=H[i-1]-1,t+=k,w+=k; while(t&lt;len&amp;&amp;w&lt;len)&#123; if(s[t]==s[w])k++; else break; t++;w++; &#125; H[i]=k;h[rank2[i]]=k; &#125;&#125;int dp[MAXN][21],ma[MAXN];void St()&#123; for(int i=2;i&lt;=len;i++)ma[i]=ma[i/2]+1; for(int i=1;i&lt;len;i++)dp[i][0]=h[i]; for(int j=1;j&lt;=20;j++)&#123; for(int i=1;i+(1&lt;&lt;j)&lt;=len;i++)&#123; dp[i][j]=min(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1]); &#125; &#125;&#125;int rmq(int l,int r)&#123; if(l==r)return inf; if(l&gt;r)swap(l,r); l++; int k=ma[r-l+1]; return min(dp[l][k],dp[r-(1&lt;&lt;k)+1][k]);&#125;vector&lt;pii&gt;v1,v2,p1,p2;void solve(int u,int v)&#123; v1.clear();v2.clear(); int uu=tp[u];int vv=tp[v]; while(uu!=vv)&#123; if(dep[uu]&gt;dep[vv])&#123; v1.pb(mp(End[uu]-dep[u]+dep[uu],End[uu])); u=fa[uu];uu=tp[u]; &#125; else&#123; v2.pb(mp(Begin[vv],Begin[vv]+dep[v]-dep[vv])); v=fa[vv];vv=tp[v]; &#125; &#125; if(dep[u]&gt;dep[v])&#123;v1.pb(mp(End[tp[u]]-dep[u]+dep[tp[u]],End[tp[v]]-dep[v]+dep[tp[v]]));&#125; else v1.pb(mp(Begin[tp[u]]+dep[u]-dep[tp[u]],Begin[tp[v]]+dep[v]-dep[tp[v]])); reverse(v2.begin(),v2.end()); for(int i=0;i&lt;v2.size();i++)v1.pb(v2[i]);&#125;int main()&#123; n=read(); inc(i,1,n)son[i]=-1; inc(i,1,n)scanf(" %c",&amp;str[i]); int u,v; inc(i,2,n)u=read(),v=read(),add(u,v),add(v,u); dfs(1,0,0);_dfs(1,1);work(); Sa();hh();St(); int q=read(); int x,y; while(q--)&#123; p1.clear();p2.clear(); u=read();v=read();x=read();y=read(); solve(u,v); for(int i=0;i&lt;v1.size();i++)p1.pb(v1[i]); solve(x,y); for(int i=0;i&lt;v1.size();i++)p2.pb(v1[i]); int l=0,r=p1[0].first,lx=0,rx=p2[0].first; int t1=p1.size();int t2=p2.size();int ans=0; while(l&lt;t1&amp;&amp;lx&lt;t2)&#123; int k=rmq(rank2[r],rank2[rx]); k=min(k,min(p1[l].second-r+1,p2[lx].second-rx+1)); if(!k)break; ans+=k; if(r+k-1&gt;=p1[l].second)&#123; l++; if(l==t1)break; r=p1[l].first; &#125; else r+=k; if(rx+k-1&gt;=p2[lx].second)&#123; lx++; if(lx==t2)break; rx=p2[lx].first; &#125; else rx+=k; &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
        <tag>SA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cf1037H]]></title>
    <url>%2F2019%2F04%2F10%2Fcf1037H%2F</url>
    <content type="text"><![CDATA[题意给定一个串$S$ $q$次查询在S[l,r]中字典序比询问串大的字典序最小的那个 题解这题有两个版本的写法 SAM考虑对原串建SAM 用线段树合并维护每个节点上$Right$集合 对于每次查询 从前往后对于每个位置找到恰好比当前前缀字典序大的 并满足区间范围的位置 然后输出即可 复杂度$O(26*nlogn)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=6e5+10;const double eps=1e-8;const int mod=1e9+9;#define ll long longusing namespace std;struct edge&#123;int t;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y)&#123;o-&gt;t=y;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;char str[MAXN];int cnt,rt,cur,tot;int Rt[MAXN],Len,fa[MAXN],dis[MAXN],ch[MAXN][31];typedef struct node&#123; int l,r,num;&#125;node;node d[MAXN*41];void update(int &amp;x,int l,int r,int t)&#123; if(!x)x=++tot; d[x].num++; if(l==r)return ; int mid=(l+r)&gt;&gt;1; if(t&lt;=mid)update(d[x].l,l,mid,t); else update(d[x].r,mid+1,r,t);&#125;void built(int x)&#123; int last=cur;cur=++cnt;dis[cur]=dis[last]+1;int p=last; update(Rt[cur],1,Len,dis[cur]); for(;p&amp;&amp;!ch[p][x];p=fa[p])ch[p][x]=cur; if(!p)fa[cur]=rt; else&#123; int q=ch[p][x]; if(dis[q]==dis[p]+1)fa[cur]=q; else&#123; int nt=++cnt;dis[nt]=dis[p]+1; memcpy(ch[nt],ch[q],sizeof(ch[q])); fa[nt]=fa[q];fa[q]=fa[cur]=nt; for(;ch[p][x]==q;p=fa[p])ch[p][x]=nt; &#125; &#125;&#125;void merge(int &amp;x,int y,int l,int r)&#123; if(!y)return ; if(!x)&#123;x=y;return ;&#125; int t=++tot;d[t]=d[x];d[t].num+=d[y].num;x=t; if(l==r)return ; int mid=(l+r)&gt;&gt;1; merge(d[x].l,d[y].l,l,mid); merge(d[x].r,d[y].r,mid+1,r);&#125;int ans;void query(int x,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;ans+=d[x].num;return ;&#125; int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid)query(d[x].l,l,mid,ql,qr); if(qr&gt;mid)query(d[x].r,mid+1,r,ql,qr);&#125;void dfs(int x)&#123; link(x)dfs(j-&gt;t),merge(Rt[x],Rt[j-&gt;t],1,Len);&#125;char s[MAXN];bool check(int x,int l,int r)&#123; if(!x||l&gt;r)return 0; ans=0;query(x,1,Len,l,r); if(ans&gt;=1)return 1; return 0;&#125;int main()&#123; scanf("%s",str);int len=strlen(str);Len=len; rt=cnt=cur=1; for(int i=0;i&lt;len;i++)built(str[i]-'`'); inc(i,1,cnt)add(fa[i],i); dfs(rt); int q=read(); while(q--)&#123; int l=read();int r=read();scanf("%s",s);int temp=rt; len=strlen(s);s[len]='`';int len1=0,len2,len3;int Temp,TEMP; int pos1=-1;int pos2; for(int i=0;i&lt;=len;i++)&#123; int t=s[i]-'`';Temp=temp;len2=len1; for(int j=t+1;j&lt;=26;j++)&#123; if(!ch[Temp][j])continue; if(!check(Rt[ch[Temp][j]],l+i,r))continue; pos1=i;pos2=j; break; &#125; if(!ch[temp][t])break; if(!check(Rt[ch[temp][t]],l+i,r))break; temp=ch[temp][t]; &#125; if(pos1==-1)printf("%d\n",-1); else&#123; for(int i=0;i&lt;pos1;i++)printf("%c",s[i]); printf("%c",(char)('a'+pos2-1)); printf("\n"); &#125; &#125; return 0;&#125; SA离线询问 把原串和询问串用一个字符链接在一起 跑$SA$ 然后按着$rank$从大到小枚举 因为对于每个询问 满足条件的必然是$rank$比询问位置大的 我们从两个方向统计答案 对于原串的下标满足$[l,r-min(rmq(rank[last],i),len)]$ 维护$rank$的最小值 然后对于下标满足$[r-len,r]$暴力枚举其$rank$以及其$lcp$是否满足条件 并维护满足条件里面$rank$最小 的下标 复杂度$O(nlogn)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=6e5+10;const double eps=1e-8;const int inf=1e9+9;#define ll long longusing namespace std;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;char str[MAXN],s[MAXN];int vis[MAXN];typedef struct node&#123; int l,r;&#125;node;node que[MAXN];int txt[MAXN],sa[MAXN],td[MAXN],rank1[MAXN],rank2[MAXN],t1[MAXN],t2[MAXN];int ma[MAXN];int dp[MAXN][21];bool cmp(int f[],int t,int w,int k)&#123;return f[t]==f[w]&amp;&amp;f[t+k]==f[w+k];&#125;void Sa()&#123; int len=strlen(str);int m=256; int *t1=rank1;int *t2=td; for(int i=0;i&lt;m;i++)txt[i]=0; for(int i=0;i&lt;len;i++)txt[str[i]]++,rank1[i]=str[i]; for(int i=1;i&lt;m;i++)txt[i]+=txt[i-1]; for(int i=len-1;i&gt;=0;i--)sa[--txt[str[i]]]=i; for(int k=1;k&lt;=len;k&lt;&lt;=1)&#123; int p=0; for(int i=len-k;i&lt;len;i++)td[p++]=i; for(int i=0;i&lt;len;i++)if(sa[i]&gt;=k)td[p++]=sa[i]-k; for(int i=0;i&lt;m;i++)txt[i]=0; for(int i=0;i&lt;len;i++)txt[rank1[i]]++; for(int i=1;i&lt;m;i++)txt[i]+=txt[i-1]; for(int i=len-1;i&gt;=0;i--)sa[--txt[rank1[td[i]]]]=td[i]; swap(rank1,td);rank1[sa[0]]=0; p=1; for(int i=1;i&lt;len;i++)rank1[sa[i]]=cmp(td,sa[i],sa[i-1],k)?p-1:p++; if(p&gt;=len)break; m=p; &#125; for(int i=0;i&lt;len;i++)rank2[sa[i]]=i;&#125;int h[MAXN],H[MAXN],Len;void hh()&#123; int len=strlen(str); for(int i=0;i&lt;len;i++)&#123; if(rank2[i]==0)continue; int t=sa[rank2[i]-1];int w=i;int k=0; if(i==0||H[i-1]&lt;=1)k=0;else k=H[i-1]-1,t+=k,w+=k; while(t&lt;len&amp;&amp;w&lt;len)&#123; if(str[t]==str[w])k++;else break; t++;w++; &#125; H[i]=k;h[rank2[i]]=k; &#125;&#125;void St()&#123; int len=strlen(str); inc(i,2,len)ma[i]=ma[i/2]+1; for(int i=1;i&lt;len;i++)dp[i][0]=h[i]; for(int j=1;j&lt;=20;j++)&#123; for(int i=1;i+(1&lt;&lt;j)&lt;=len;i++)&#123; dp[i][j]=min(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1]); &#125; &#125;&#125;int rmq(int l,int r)&#123; l++; int k=ma[r-l+1]; return min(dp[l][k],dp[r-(1&lt;&lt;k)+1][k]);&#125;int minn[MAXN&lt;&lt;2],LEN[MAXN];void built(int x,int l,int r)&#123; minn[x]=inf; if(l==r)return ; int mid=(l+r)&gt;&gt;1; built(x&lt;&lt;1,l,mid); built(x&lt;&lt;1|1,mid+1,r);&#125;void update(int x,int l,int r,int t,int k)&#123; minn[x]=min(minn[x],k); if(l==r)return ; int mid=(l+r)&gt;&gt;1; if(t&lt;=mid)update(x&lt;&lt;1,l,mid,t,k); else update(x&lt;&lt;1|1,mid+1,r,t,k);&#125;int ans1;void query(int x,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;ans1=min(ans1,minn[x]);return ;&#125; int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid)query(x&lt;&lt;1,l,mid,ql,qr); if(qr&gt;mid)query(x&lt;&lt;1|1,mid+1,r,ql,qr);&#125;pii ans[MAXN];void solve()&#123; int len=strlen(str);int last=0; for(int i=len-1;i&gt;=1;i--)&#123; //cout&lt;&lt;i&lt;&lt;":::: "&lt;&lt;endl; if(!vis[sa[i]]&amp;&amp;sa[i]&lt;Len)&#123; last=i; update(1,1,Len,sa[i]+1,i); continue; &#125; if(!vis[sa[i]])continue; int k=vis[sa[i]]; int l=que[k].l;int r=que[k].r; if(last)r-=min(rmq(i,last),LEN[k]); //cout&lt;&lt;l&lt;&lt;" "&lt;&lt;r&lt;&lt;endl; ans1=inf; if(l&lt;=r)query(1,1,Len,l,r); for(int j=max(que[k].r-LEN[k],que[k].l-1);j&lt;que[k].r;j++)&#123; if(rank2[j]&lt;=i)continue; int k1=min(rmq(i,rank2[j]),LEN[k]); if(j+k1+1&gt;que[k].r)continue; if(ans1&gt;rank2[j])ans1=rank2[j]; &#125; if(ans1==inf)ans[k].first=-1; else ans[k].first=ans1,ans[k].second=rmq(i,ans1); &#125;&#125;int main()&#123; scanf("%s",str);int len=strlen(str);Len=len;str[len]='$';len++; built(1,1,Len); int n=read(); inc(i,1,n)&#123; que[i].l=read();que[i].r=read(); scanf("%s",s);int len1=strlen(s);LEN[i]=len1; for(int j=0;j&lt;len1;j++)&#123; if(j==0)vis[len]=i; str[len++]=s[j]; &#125; str[len++]='$'; &#125; str[len]='\0'; Sa();hh();St(); //cout&lt;&lt;str&lt;&lt;endl; //inc(i,1,len-1)cout&lt;&lt;sa[i]&lt;&lt;" "; //cout&lt;&lt;endl; solve(); inc(i,1,n)&#123; if(ans[i].first==-1)printf("%d\n",-1); else&#123; for(int j=sa[ans[i].first];j&lt;=sa[ans[i].first]+ans[i].second;j++)printf("%c",str[j]); printf("\n"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>SA</tag>
        <tag>线段树</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cf547E(SAM+dfs序+主席树)]]></title>
    <url>%2F2019%2F04%2F06%2Fcf547E-SAM-dfs%E5%BA%8F-%E4%B8%BB%E5%B8%AD%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题意给定$n$个串 $q$次查询 每次查询$(l,r,k)$ 表示下标为$k$的串在下标为$[l,r]$的串中出现的次数的和 题解我们考虑建广义的SAM 这样所有串的情况都可以在一颗后缀树上表示 对于每个串我们找到他的最佳匹配位置 问题转化为 对于查询 我们在他最佳匹配位置的子树中统计节点的权值在[l,r]的个数 这样 $dfs$序对于序列建可持久化线段树 然后查询答案即可 复杂度$O(qlogn)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=6e5+10;const double eps=1e-8;const int mod=1e9+9;#define ll long longusing namespace std;struct edge&#123;int t;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y)&#123;o-&gt;t=y;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;string str[MAXN];int n,m;int rt,cnt,cur;int dis[MAXN],ch[MAXN][26],fa[MAXN],tag[MAXN];void built(int x,int id)&#123; int last=cur;cur=++cnt;dis[cur]=dis[last]+1;tag[cur]=id;int p=last; for(;p&amp;&amp;!ch[p][x];p=fa[p])ch[p][x]=cur; if(!p)fa[cur]=rt; else&#123; int q=ch[p][x]; if(dis[q]==dis[p]+1)fa[cur]=q; else&#123; int nt=++cnt;dis[nt]=dis[p]+1; memcpy(ch[nt],ch[q],sizeof(ch[q])); fa[nt]=fa[q];fa[q]=fa[cur]=nt; for(;ch[p][x]==q;p=fa[p])ch[p][x]=nt; &#125; &#125;&#125;int id[MAXN];void solve()&#123; inc(i,1,n)&#123; int len=str[i].size();int temp=rt; for(int j=0;j&lt;len;j++)&#123; int t=str[i][j]-'a'; if(ch[temp][t])temp=ch[temp][t]; else&#123; int p=temp; for(;p&amp;&amp;!ch[p][t];p=fa[p]); if(!p)temp=rt;else temp=ch[p][t]; &#125; &#125; id[i]=temp; &#125;&#125;int dfn[MAXN],tot,num[MAXN],fdfn[MAXN];void dfs(int x)&#123; dfn[x]=++tot;num[x]=1;fdfn[tot]=x; link(x)&#123; dfs(j-&gt;t); num[x]+=num[j-&gt;t]; &#125;&#125;typedef struct node&#123; int l,r,sum;&#125;node;node d[MAXN*21];int Rt[MAXN],tot1;void update(int &amp;x,int y,int l,int r,int t)&#123; x=++tot1;d[x]=d[y];d[x].sum++; if(l==r)return ; int mid=(l+r)&gt;&gt;1; if(t&lt;=mid)update(d[x].l,d[y].l,l,mid,t); else update(d[x].r,d[y].r,mid+1,r,t);&#125;int ans;void query(int x,int y,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;ans+=d[y].sum-d[x].sum;return ;&#125; int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid)query(d[x].l,d[y].l,l,mid,ql,qr); if(qr&gt;mid)query(d[x].r,d[y].r,mid+1,r,ql,qr);&#125;int main()&#123; ios::sync_with_stdio(false); rt=cur=cnt=1; cin&gt;&gt;n&gt;&gt;m; inc(i,1,n)cin&gt;&gt;str[i]; inc(i,1,n)&#123; int len=str[i].size(); cur=1; for(int j=0;j&lt;len;j++)built(str[i][j]-'a',i); &#125; solve(); inc(i,1,cnt)add(fa[i],i); dfs(rt); inc(i,1,tot)&#123; if(!tag[fdfn[i]])Rt[i]=Rt[i-1]; else update(Rt[i],Rt[i-1],1,n,tag[fdfn[i]]); &#125; int l,r,x; while(m--)&#123; cin&gt;&gt;l&gt;&gt;r&gt;&gt;x;x=id[x]; ans=0;query(Rt[dfn[x]-1],Rt[dfn[x]+num[x]-1],1,n,l,r); printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>SAM</tag>
        <tag>dfs序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cf961F(hash+线段树+二分)]]></title>
    <url>%2F2019%2F04%2F06%2Fcf961F-hash-%E7%BA%BF%E6%AE%B5%E6%A0%91-%E4%BA%8C%E5%88%86%2F</url>
    <content type="text"><![CDATA[题意给定一个字符串$T$ 求前$\lceil \frac{|T|}{2} \rceil$ 个位置与其关于对称轴对应位置形成的串 在满足以下条件下的最长前缀 前缀的长度小于串长 前缀长度为奇数 在是前缀的同时也是串的后缀 题解在考虑没有长度是奇数限制的情况下 直接对每个串做二分 $hash$来$check$即可 因为是奇数 所以这个前缀必然存在对称中心 所以我们可以考虑枚举这个中心 去$check$这个中心最远能往前影响的最远位置 然后对于这段区间维护区间最值 可以用线段树维护 复杂度$O(nlogn)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=2e6+10;const double eps=1e-8;const int mod=1e9+9;#define ll long longusing namespace std;const int mod1=1e9+7;const int mod2=1e9+9;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;char str[MAXN];int n;ll sum1[MAXN],sum2[MAXN];ll Sum1[MAXN],Sum2[MAXN];bool judge(int x1,int y1,int x2,int y2)&#123; ll ans1=(sum1[y1]-sum1[x1-1]*Sum1[y1-x1+1]%mod1+mod1)%mod1; ll ans2=(sum1[y2]-sum1[x2-1]*Sum1[y2-x2+1]%mod1+mod1)%mod1; if(ans1!=ans2)return false; ans1=(sum2[y1]-sum2[x1-1]*Sum2[y1-x1+1]%mod2+mod2)%mod2; ans2=(sum2[y2]-sum2[x2-1]*Sum2[y2-x2+1]%mod2+mod2)%mod2; if(ans1!=ans2)return false; return true;&#125;bool check(int t,int x,int y)&#123; int len=x-t+1; if(y+len-1&gt;n)return false; if(!judge(t,x,y-x+t,y))return false; if(!judge(x,x+len-1,y,y+len-1))return false; return true;&#125;int maxx[MAXN&lt;&lt;2];void push(int x)&#123; if(maxx[x]!=0)&#123; maxx[x&lt;&lt;1]=max(maxx[x&lt;&lt;1],maxx[x]); maxx[x&lt;&lt;1|1]=max(maxx[x&lt;&lt;1|1],maxx[x]); maxx[x]=0; &#125;&#125;void update(int x,int l,int r,int ql,int qr,int t)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;maxx[x]=max(maxx[x],t);return ;&#125; int mid=(l+r)&gt;&gt;1; push(x); if(ql&lt;=mid)update(x&lt;&lt;1,l,mid,ql,qr,t); if(qr&gt;mid)update(x&lt;&lt;1|1,mid+1,r,ql,qr,t);&#125;vector&lt;int&gt;vec;void query(int x,int l,int r)&#123; if(l==r)&#123;vec.pb(max(-1,(maxx[x]-l)*2+1));return ;&#125; int mid=(l+r)&gt;&gt;1; push(x); query(x&lt;&lt;1,l,mid); query(x&lt;&lt;1|1,mid+1,r);&#125;int main()&#123; n=read();scanf("%s",str+1); Sum1[0]=Sum2[0]=1; inc(i,1,n)Sum1[i]=Sum1[i-1]*131%mod1,Sum2[i]=Sum2[i-1]*233%mod2; inc(i,1,n)sum1[i]=sum1[i-1]*131+str[i],sum1[i]%=mod1; inc(i,1,n)sum2[i]=sum2[i-1]*233+str[i],sum2[i]%=mod2; int x,y;x=y=(n-1)/2+1; if(n%2==0)y++;else x--,y++; dec(i,(n-1)/2+1,1)&#123; int l=1;int r=x;int ans=0; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(check(mid,x,y))ans=mid,r=mid-1; else l=mid+1; &#125; if(!ans)&#123;x--;y++;continue;&#125; update(1,1,n,ans,x,x); x--;y++; &#125; query(1,1,n); for(int i=1;i&lt;=(n-1)/2+1;i++)printf("%d ",vec[i-1]); printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>hash</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cf616F(SAM+树dp)]]></title>
    <url>%2F2019%2F04%2F04%2Fcf616F-SAM-%E6%A0%91dp%2F</url>
    <content type="text"><![CDATA[题意给你n个串 每个串都有一个价值$c_i$ 然后让你构造一个串$S$ $S$的价值定义为: $F(S)=\sum_{i=1}^{n}c_ip_{S,i}|S|$ $p_{S,i}$ 表示在第$T_i$中$S$出现的次数 $|S|$表示串的长度 问 如何选择$S$能得到最大价值 输出最大价值 题解我们考虑把所有串建广义的后缀自动机 众所周知的 $dis[fa[x]]+1$ 到$dis[x]$是本周不同子串 然后求出其在所有串中的价值和 这个可以在后缀上统计得到 复杂度 O$(\sum_{i-1}^{n}|T_i|)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=1e6+10;const double eps=1e-8;const int mod=1e9+9;#define ll long longconst ll inf=1e18;using namespace std;struct edge&#123;int t;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y)&#123;o-&gt;t=y;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int n;int ch[MAXN][26],fa[MAXN],dis[MAXN];ll sum[MAXN];int rt,cur,cnt;void built(int x,int vul)&#123; int last=cur;cur=++cnt;dis[cur]=dis[last]+1;sum[cur]=vul;int p=last; for(;p&amp;&amp;!ch[p][x];p=fa[p])ch[p][x]=cur; if(!p)fa[cur]=rt; else&#123; int q=ch[p][x]; if(dis[q]==dis[p]+1)fa[cur]=q; else&#123; int nt=++cnt;dis[nt]=dis[p]+1; memcpy(ch[nt],ch[q],sizeof(ch[q])); fa[nt]=fa[q];fa[q]=fa[cur]=nt; for(;ch[p][x]==q;p=fa[p])ch[p][x]=nt; &#125; &#125;&#125;string str[100005];int a[MAXN];ll maxx;void dfs(int x)&#123; link(x)&#123; dfs(j-&gt;t);sum[x]+=sum[j-&gt;t]; &#125; if(x!=rt&amp;&amp;dis[x]&gt;dis[fa[x]])maxx=max(maxx,max(sum[x]*(dis[fa[x]]+1),sum[x]*dis[x]));&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n; inc(i,1,n)cin&gt;&gt;str[i]; inc(i,1,n)cin&gt;&gt;a[i]; rt=cnt=cur=1; inc(i,1,n)&#123; int sz=str[i].size();cur=1; for(int j=0;j&lt;sz;j++)built(str[i][j]-'a',a[i]); &#125; inc(i,1,cnt)add(fa[i],i); maxx=0;dfs(rt); cout&lt;&lt;maxx&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cf232D(后缀数组+主席树+ST表+二分)]]></title>
    <url>%2F2019%2F04%2F03%2Fcf232D-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84-%E4%B8%BB%E5%B8%AD%E6%A0%91-ST%E8%A1%A8-%E4%BA%8C%E5%88%86%2F</url>
    <content type="text"><![CDATA[题意给定长度为$n$的整数序列 $q​$次查询 区间$[l,r]​$能’’匹配’’多少长度与其一致且不相交的区间 匹配的定义是for all $i​$ $(0 ≤ i≤ r1 - l1)​$ the following condition holds: $h1 + i + hl2 + i = hl1 + hl2​$ 题解:从这个匹配入手 对于两个串 $[l,r]$ $[lx,rx]$ for all $i$ $(1 ≤ i≤ r - l)$ $h_{i+l}-h_{i+l-1}=h_{lx+i-1}-h_{i+lx}$ 所以把这个串复制一遍加在后面 注意用一个从未出现的数隔开 然后前面一段用$h_i-h_{i+1}$替代 后面一部分用$h_{i}-h_{i-1}$ 替代 然后链接以后跑后缀数组 对于每个查询 找到$lcp&gt;=r-l$的最大范围[l,r] 然后用主席树维护答案即可 复杂度$O(nlogn+qlogn)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;const int mod=1e9+9;const int inf=1e9+9;#define ll long longusing namespace std;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int n,a[MAXN],sz;int str[MAXN],len;vector&lt;int&gt;vec;int t1[MAXN],t2[MAXN],txt[MAXN],rank1[MAXN],rank2[MAXN],td[MAXN],sa[MAXN];bool cmp(int f[],int t,int w,int k)&#123;return f[t]==f[w]&amp;&amp;f[t+k]==f[w+k];&#125;void Sa()&#123; int m=++sz; int *td=t1;int *rank1=t2; for(int i=0;i&lt;m;i++)txt[i]=0; for(int i=0;i&lt;len;i++)txt[str[i]]++,rank1[i]=str[i]; for(int i=1;i&lt;m;i++)txt[i]+=txt[i-1]; for(int i=len-1;i&gt;=0;i--)sa[--txt[str[i]]]=i; for(int k=1;k&lt;=len;k&lt;&lt;=1)&#123; int p=0; for(int i=len-k;i&lt;len;i++)td[p++]=i; for(int i=0;i&lt;len;i++)if(sa[i]&gt;=k)td[p++]=sa[i]-k; for(int i=0;i&lt;m;i++)txt[i]=0; for(int i=0;i&lt;len;i++)txt[rank1[i]]++; for(int i=1;i&lt;m;i++)txt[i]+=txt[i-1]; for(int i=len-1;i&gt;=0;i--)sa[--txt[rank1[td[i]]]]=td[i]; swap(rank1,td);rank1[sa[0]]=0; p=1; for(int i=1;i&lt;len;i++)rank1[sa[i]]=cmp(td,sa[i],sa[i-1],k)?p-1:p++; if(p&gt;=len)break; m=p; &#125; for(int i=0;i&lt;len;i++)rank2[sa[i]]=i;&#125;int h[MAXN],H[MAXN];void hh()&#123; for(int i=0;i&lt;len;i++)&#123; if(!rank2[i])continue; int t=sa[rank2[i]-1];int w=i;int k; if(i==0||H[i-1]&lt;=1)k=0;else k=H[i-1]-1,t+=k,w+=k; while(t&lt;len&amp;&amp;w&lt;len)&#123; if(str[w]==str[t])k++; else break; w++;t++; &#125; H[i]=k;h[rank2[i]]=k; &#125;&#125;int dp[MAXN][21],ma[MAXN];void St()&#123; for(int i=2;i&lt;=len;i++)ma[i]=ma[i/2]+1; for(int i=1;i&lt;len;i++)dp[i][0]=h[i]; for(int j=1;j&lt;=20;j++)&#123; for(int i=1;i+(1&lt;&lt;j)&lt;=len;i++)&#123; dp[i][j]=min(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1]); &#125; &#125;&#125;int rmq(int l,int r)&#123; l++; if(l&gt;r)return 0; int k=ma[r-l+1]; return min(dp[l][k],dp[r-(1&lt;&lt;k)+1][k]);&#125;pii solve(int x,int t)&#123; int l=x+1;int r=len-1;pii ans;ans.second=x; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(rmq(x,mid)&gt;=t)ans.second=mid,l=mid+1; else r=mid-1; &#125; l=1;r=x-1;ans.first=x+1; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(rmq(mid,x)&gt;=t)ans.first=mid,r=mid-1; else l=mid+1; &#125; return ans;&#125;int rt[MAXN];int cnt;typedef struct node&#123; int l,r,sum;&#125;node;node d[MAXN*21];void update(int &amp;x,int y,int l,int r,int t)&#123; x=++cnt;d[x]=d[y];d[x].sum++; if(l==r)return ; int mid=(l+r)&gt;&gt;1; if(t&lt;=mid)update(d[x].l,d[y].l,l,mid,t); else update(d[x].r,d[y].r,mid+1,r,t);&#125;int ans1;void query(int x,int y,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;ans1+=d[y].sum-d[x].sum;return ;&#125; int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid)query(d[x].l,d[y].l,l,mid,ql,qr); if(qr&gt;mid)query(d[x].r,d[y].r,mid+1,r,ql,qr);&#125;int main()&#123; n=read();len=0; inc(i,1,n)a[i]=read(); inc(i,1,n-1)str[len++]=a[i]-a[i+1],vec.pb(str[len-1]); str[len++]=inf;vec.pb(str[len-1]); inc(i,2,n)str[len++]=a[i]-a[i-1],vec.pb(str[len-1]); str[len++]=-inf;vec.pb(str[len-1]); sort(vec.begin(),vec.end()); sz=unique(vec.begin(),vec.end())-vec.begin(); for(int i=0;i&lt;len;i++)str[i]=lower_bound(vec.begin(),vec.begin()+sz,str[i])-vec.begin()+1; Sa();hh();St(); for(int i=1;i&lt;len;i++)&#123; if(sa[i]&lt;n)rt[i]=rt[i-1]; else&#123; update(rt[i],rt[i-1],1,n,sa[i]-n+1); &#125; &#125; int q=read(); while(q--)&#123; int l=read();int r=read(); if(l==r)printf("%d\n",n-1); else&#123; pii ans=solve(rank2[l-1],r-l); if(ans.first&gt;ans.second)&#123;printf("0\n");continue;&#125; ans1=0; if(2*l-r-1&gt;=1)query(rt[ans.first-1],rt[ans.second],1,n,1,2*l-r-1); if(n-r+l&gt;r)query(rt[ans.first-1],rt[ans.second],1,n,r+1,n-r+l); printf("%d\n",ans1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>后缀数组</tag>
        <tag>主席树</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cf524F(后缀数组+线段树)]]></title>
    <url>%2F2019%2F04%2F03%2Fcf524F-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84-%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题意给定一个括号序列,现在能进行两类操作: 循环移位,将末尾的字符移动到开头 在任意位置加入任意类型字符 问在满足加入字符最小的情况下,输出合法的括号序列,如果有多种情况满足长度最下,则输出字典序最小的 题解首先 对于加入字符最少 必然是加入$|左括号num-右括号num|$个 若左括号多 必然在末尾加入右括号 反之则在开端加入左括号 对于循环移位操作 本质形成一个环 那么我们考虑用线段树判当前子串加入相关字符后能否构成合法括号序列 用后缀数组来维护字典序最小的方案 复杂度O$(nlogn)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=2e6+10;const double eps=1e-8;const int inf=1e9+9;#define ll long longusing namespace std;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int n;int sum[MAXN];int minn[MAXN&lt;&lt;2],maxx[MAXN&lt;&lt;2];void built(int x,int l,int r)&#123; minn[x]=inf;maxx[x]=-inf; if(l==r)&#123;minn[x]=maxx[x]=sum[l];return ;&#125; int mid=(l+r)&gt;&gt;1; built(x&lt;&lt;1,l,mid); built(x&lt;&lt;1|1,mid+1,r); minn[x]=min(minn[x&lt;&lt;1],minn[x&lt;&lt;1|1]); maxx[x]=max(maxx[x&lt;&lt;1],maxx[x&lt;&lt;1|1]);&#125;int ans;void query_min(int x,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;ans=min(ans,minn[x]);return ;&#125; int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid)query_min(x&lt;&lt;1,l,mid,ql,qr); if(qr&gt;mid)query_min(x&lt;&lt;1|1,mid+1,r,ql,qr);&#125;void query_max(int x,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;ans=max(ans,maxx[x]);return ;&#125; int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid)query_max(x&lt;&lt;1,l,mid,ql,qr); if(qr&gt;mid)query_max(x&lt;&lt;1|1,mid+1,r,ql,qr);&#125;int txt[MAXN],rank1[MAXN],sa[MAXN],td[MAXN],t1[MAXN],t2[MAXN],rank2[MAXN];bool cmp(int f[],int t,int w,int k)&#123;return f[t]==f[w]&amp;&amp;f[t+k]==f[w+k];&#125;void Sa(char str[])&#123; int len=strlen(str);int m=256; int *td=t1;int *rank1=t2; for(int i=0;i&lt;m;i++)txt[i]=0; for(int i=0;i&lt;len;i++)rank1[i]=str[i],txt[str[i]]++; for(int i=1;i&lt;m;i++)txt[i]+=txt[i-1]; for(int i=len-1;i&gt;=0;i--)sa[--txt[str[i]]]=i; for(int k=1;k&lt;=len;k&lt;&lt;=1)&#123; int p=0; for(int i=len-k;i&lt;len;i++)td[p++]=i; for(int i=0;i&lt;len;i++)if(sa[i]&gt;=k)td[p++]=sa[i]-k; for(int i=0;i&lt;m;i++)txt[i]=0; for(int i=0;i&lt;len;i++)txt[rank1[i]]++; for(int i=1;i&lt;m;i++)txt[i]+=txt[i-1]; for(int i=len-1;i&gt;=0;i--)sa[--txt[rank1[td[i]]]]=td[i]; swap(rank1,td);rank1[sa[0]]=0; p=1; for(int i=1;i&lt;len;i++)rank1[sa[i]]=cmp(td,sa[i],sa[i-1],k)?p-1:p++; if(p&gt;=len)break; m=p; &#125; for(int i=0;i&lt;len;i++)rank2[sa[i]]=i;&#125;char str[MAXN];int main()&#123; scanf("%s",str);n=strlen(str); inc(i,0,n-1)str[n+i]=str[i];str[2*n]='\0'; inc(i,0,2*n-1)if(str[i]=='(')sum[i+1]=-1;else sum[i+1]=1; inc(i,1,2*n)sum[i]+=sum[i-1]; built(1,1,2*n);Sa(str); int cnt=0; for(int i=0;i&lt;n;i++)if(str[i]=='(')cnt++;else cnt--; if(cnt&gt;0)&#123; int maxx=inf,pos=0; for(int i=0;i&lt;n;i++)&#123; int l=i+1;int r=i+n; ans=-inf;query_max(1,1,2*n,l,r); if(ans&gt;sum[i])continue; ans=-inf;query_max(1,1,2*n,r,r); if(ans-sum[i]+cnt!=0)continue; if(maxx&gt;rank2[i])pos=i,maxx=rank2[i]; &#125; for(int i=pos;i&lt;pos+n;i++)printf("%c",str[i]); for(int i=1;i&lt;=cnt;i++)printf(")"); &#125; else&#123; int maxx=inf,pos=0; for(int i=0;i&lt;n;i++)&#123; int l=i+1;int r=i+n; ans=-inf;query_max(1,1,2*n,l,r); if(ans+cnt&gt;sum[i])continue; ans=-inf;query_max(1,1,2*n,r,r); if(ans-sum[i]+cnt!=0)continue; if(maxx&gt;rank2[i])pos=i,maxx=rank2[i]; &#125; cnt*=-1; for(int i=1;i&lt;=cnt;i++)printf("("); for(int i=pos;i&lt;pos+n;i++)printf("%c",str[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cf86C(AC自动机+dp)]]></title>
    <url>%2F2019%2F04%2F02%2Fcf86C-AC%E8%87%AA%E5%8A%A8%E6%9C%BA-dp%2F</url>
    <content type="text"><![CDATA[题意给定$m$个字符串 问构造长度为$n$的串的方案数 构造串需满足 对于任意位置 $i$ 都存在一个子区间[l,r] 包含$i$且子区间对应m个串中的任意一个 题解AC自动机+DP 我们可以设$dp[i][j][k]$ 表示已经构造了长度为$i$的串 且在自动机中第$j$状态 且存在$k$字符属于失配状态 对于每个位置 我们找到其在自动机上 m个串为其后缀的最长的那个串的长度 设加入四种字符其中一个后达到的目的状态为$x$ 当前状态为$y$ 那么转移就是 若当前失配的长度$k&lt;maxdis$ 那么 $dp[i+1][x][0]+=dp[i][y][k]$ 反之则 $dp[i+1][x][k+1]+=dp[i][y][k]$ 复杂度为$O(NM*400)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;const int mod=1e9+9;#define ll long longusing namespace std;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int T[MAXN];typedef struct node&#123; int dep,ch[4],fair,pos; bool vis;&#125;node;int rt,n,m,cnt;node d[105];void newnode(int &amp;x,int y)&#123; x=++cnt;d[x].dep=d[y].dep+1;d[x].fair=0; d[x].pos=0;&#125;void insert(char str[])&#123; int len=strlen(str);int temp=rt; for(int i=0;i&lt;len;i++)&#123; int t=T[str[i]-'A']; if(!d[temp].ch[t])newnode(d[temp].ch[t],temp); temp=d[temp].ch[t]; &#125; d[temp].vis=1;d[temp].pos=temp;&#125;queue&lt;int&gt;que;void Ac()&#123; que.push(rt); while(!que.empty())&#123; int x=que.front();que.pop(); for(int i=0;i&lt;4;i++)&#123; if(!d[x].ch[i])&#123;d[x].ch[i]=d[d[x].fair].ch[i];continue;&#125; if(!d[x].fair)&#123;d[d[x].ch[i]].fair=rt;que.push(d[x].ch[i]);continue;&#125; int temp=d[x].fair; while(temp&amp;&amp;!d[temp].ch[i])temp=d[temp].fair; if(!temp)d[d[x].ch[i]].fair=rt;else d[d[x].ch[i]].fair=d[temp].ch[i]; if(d[d[d[x].ch[i]].fair].dep&gt;d[d[d[x].ch[i]].pos].dep)d[d[x].ch[i]].pos=d[d[d[x].ch[i]].fair].pos; que.push(d[x].ch[i]); &#125; &#125;&#125;int dp[1005][101][21];char str[21];int main()&#123; T['A'-'A']=0;T['C'-'A']=1;T['G'-'A']=2;T['T'-'A']=3; n=read();m=read();newnode(rt,0);d[rt].dep=0; inc(i,1,m)scanf("%s",str),insert(str); Ac();dp[0][1][0]=1; for(int i=0;i&lt;n;i++)&#123; for(int j=1;j&lt;=cnt;j++)&#123; for(int k=0;k&lt;4;k++)&#123; int pos=d[j].ch[k]; //cout&lt;&lt;j&lt;&lt;"===="&lt;&lt;k&lt;&lt;" "&lt;&lt;pos&lt;&lt;" "&lt;&lt;d[j].ch[k]&lt;&lt;endl; if(!pos)continue; for(int p=0;p&lt;=9;p++)&#123; if(d[d[pos].pos].dep&gt;p)&#123; //cout&lt;&lt;j&lt;&lt;" "&lt;&lt;k&lt;&lt;" "&lt;&lt;pos&lt;&lt;"::: "&lt;&lt;p&lt;&lt;endl; dp[i+1][pos][0]+=dp[i][j][p];dp[i+1][pos][0]%=mod; &#125; else&#123; dp[i+1][pos][p+1]+=dp[i][j][p];dp[i+1][pos][p+1]%=mod; &#125; &#125; &#125; &#125;// cout&lt;&lt;i+1&lt;&lt;":::"&lt;&lt;endl;// for(int j=1;j&lt;=cnt;j++)&#123;// for(int k=0;k&lt;=10;k++)cout&lt;&lt;dp[i+1][j][k]&lt;&lt;" ";// cout&lt;&lt;endl;// &#125; &#125; ll ans=0; for(int i=1;i&lt;=cnt;i++)ans+=dp[n][i][0],ans%=mod; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cometOJ#0C.项链与计数(并查集)]]></title>
    <url>%2F2019%2F04%2F01%2FcometOJ-0C-%E9%A1%B9%E9%93%BE%E4%B8%8E%E8%AE%A1%E6%95%B0-%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[题目描述在图论中，“简单环” 被定义为一个点数和边数相等的回路，并且这条回路上没有出现重复的点或边。 对于一个无向图，小象定义 “项链” 是由一些简单环组成的子图，不妨设项链包括 k 个简单环 $C_1, C_2, \ldots…, C_k (k \in \mathbb{N}^+)$，那么项链需要满足： 当且仅当 $|i - j| \leq 1$ 时，简单环 $C_i $和 $C_j $共用顶点； 简单环 $C_i$和 $C_{i +1}$恰好共用一个顶点； 任意两个不同的简单环 $C_i$和 $C_j(i \neq j)$ 没有共用边。 注意，按照上述定义，一个简单环也可以看做是项链。 小象画了一个 $n$个点的无向图，其中点被从 $1$到 $n$ 编号。最开始图中没有任何一条边，然后他往图中依次添加了 $m$ 条无向边，整个图逐渐变得复杂起来。 他很好奇，在他每添加了一条边之后，整个图里存在多少对点 $(u, v)$满足 $u \neq v$且存在一个项链 $C_1,C_2, \ldots…, C_k$使得 $u \in C_1$, $v \in C_k$。需要一提的是，小象认为 $(u, v)$ 和 $(v, u)$ 是相同的点对。 不妨设在添加了 $i$ 条边后这样的点对数量为 $f(i)$,小象希望你能帮他计算 $\bigoplus\limits_{i = 1}^{m}{(i \cdot f(i))}$的值，这里$ \oplus​$ 表示按位异或运算符 题解对于所有的边 构造生成树 对于所有边根据生成树的形态 分成树边和非树边 对于加入树边 不会对答案产生影响 对于加入非树边 则这个树链上任意两点都是满足条件的 我们可以用并查集缩点 并在缩点的过程中维护价值即可 复杂度$O(n+m)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,double&gt;//#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=1e6+10;const double eps=1e-4;#define ll long longusing namespace std;const int inf=1e9;//struct edge&#123;int t;double v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;//void add(int x,int y,double vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;struct FastIO&#123; static const int S=200; int wpos; char wbuf[S]; FastIO():wpos(0)&#123;&#125; inline int xchar() &#123; static char buf[S]; static int len=0,pos=0; if(pos==len) pos=0,len=fread(buf,1,S,stdin); if(pos==len) exit(0); return buf[pos++]; &#125; inline int read() &#123; int s=1,c=xchar(),x=0; while(c&lt;=32) c=xchar(); if(c=='-') s=-1,c=xchar(); for(;'0'&lt;=c&amp;&amp;c&lt;='9';c=xchar()) x=x*10+c-'0'; return x*s; &#125; ~FastIO() &#123; if(wpos) fwrite(wbuf,1,wpos,stdout),wpos=0; &#125;&#125;io;vector&lt;int&gt;vec[MAXN];int f[MAXN],sz[MAXN];bool vis[MAXN];int find1(int x)&#123; if(x==f[x])return x; else return f[x]=find1(f[x]);&#125;int fa[MAXN],dep[MAXN];void dfs(int x,int pre,int deep)&#123; fa[x]=pre;dep[x]=deep+1;vis[x]=1; for(int i=0;i&lt;vec[x].size();i++)&#123; if(vec[x][i]==pre)continue; dfs(vec[x][i],x,deep+1); &#125;&#125;typedef struct node&#123; int x,y;&#125;node;node d[MAXN&lt;&lt;1];bool T[MAXN&lt;&lt;1];int main()&#123; int _=io.read(); while(_--)&#123; int n=io.read();int m=io.read(); inc(i,1,n)f[i]=i; inc(i,1,n)vec[i].clear(),vis[i]=0; inc(i,1,m)T[i]=0; inc(i,1,m)&#123; d[i].x=io.read();d[i].y=io.read(); int t1=find1(d[i].x);int t2=find1(d[i].y); if(t1==t2)continue; f[t1]=t2;T[i]=1; vec[d[i].x].pb(d[i].y); vec[d[i].y].pb(d[i].x); &#125; inc(i,1,n)if(!vis[i])dfs(i,0,0); inc(i,1,n)f[i]=i,sz[i]=1; ll ans=0,sum=0,ans1=0; int x,y; inc(i,1,m)&#123; if(T[i])&#123;ans^=sum*i;continue;&#125; x=d[i].x;y=d[i].y; if(f[x]==f[y])&#123;ans^=sum*i;continue;&#125; ans1=0;x=find1(x);y=find1(y); while(x!=y)&#123; if(dep[x]&lt;dep[y])swap(x,y); ans1+=sz[x]; sum-=1ll*sz[x]*(sz[x]-1)/2; f[x]=fa[x]; x=find1(x); &#125; x=find1(x); sum-=1ll*sz[x]*(sz[x]-1)/2;sz[x]+=ans1; sum+=1ll*sz[x]*(sz[x]-1)/2; ans^=sum*i; &#125; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj4229(并查集)]]></title>
    <url>%2F2019%2F04%2F01%2Fbzoj4229-%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[题目描述现在，我想知道自己是否还有选择。 给定n个点m条边的无向图以及顺序发生的q个事件。 每个事件都属于下面两种之一： 1、删除某一条图上仍存在的边 2、询问是否存在两条边不相交的路径可以从点u出发到点v 题解神奇的并查集 %%%% 我们考虑离线下来 从后到前做 把删边处理成加边(注意重边) 把剩下的边分成两部分 树边和非树边 然后对于询问上被删除的边 从后往前 分为树边和非树边 然后把两个部分树边构成生成树 并把初始情况下的非树边加入 对生成树缩点 用并查集维护 对于询问中还未加入的边 用并查集维护即可 对于询问的查询 只要判断两点在并查集中是否联通即可 时间复杂度$O(n+m)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,double&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=2e5+10;const double eps=1e-4;#define ll long longusing namespace std;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;struct edge&#123;int t;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y)&#123;o-&gt;t=y;o-&gt;next=h[x];h[x]=o++;&#125;int n,m,q;bool T[MAXN];int f[MAXN],F[MAXN]; int find1(int x)&#123; if(x==f[x])return x; return f[x]=find1(f[x]);&#125; int Find1(int x)&#123; if(x==F[x])return x; return F[x]=Find1(F[x]);&#125; typedef struct node&#123; int id,x,y; friend bool operator&lt;(node aa,node bb)&#123; if(aa.x==bb.x)return aa.y&lt;bb.y; return aa.x&lt;bb.x; &#125;&#125;node;node d[MAXN],Edge[MAXN];set&lt;node&gt;s;set&lt;node&gt;::iterator ite; char str[11];bool vis[MAXN],use[MAXN];int dep[MAXN],fa[MAXN],sz[MAXN];void dfs(int x,int pre,int deep)&#123; fa[x]=pre;dep[x]=deep+1;vis[x]=1; link(x)&#123; if(j-&gt;t==pre)continue; dfs(j-&gt;t,x,deep+1); &#125;&#125;stack&lt;int&gt;S;int main()&#123; n=read();m=read();q=read(); inc(i,1,n)f[i]=i,F[i]=i,sz[i]=1; inc(i,1,m)&#123; Edge[i].x=read();Edge[i].y=read(); if(Edge[i].x&gt;Edge[i].y)swap(Edge[i].x,Edge[i].y); s.insert((node)&#123;i,Edge[i].x,Edge[i].y&#125;); &#125; inc(i,1,q)&#123; scanf("%s %d %d",str,&amp;d[i].x,&amp;d[i].y); if(str[0]=='P')d[i].id=0; else&#123; if(d[i].x&gt;d[i].y)swap(d[i].x,d[i].y); d[i].id=1; ite=s.lower_bound((node)&#123;0,d[i].x,d[i].y&#125;); T[ite-&gt;id]=1;s.erase(ite); &#125; &#125; inc(i,1,m)&#123; if(T[i])continue; int t1=find1(Edge[i].x);int t2=find1(Edge[i].y); if(t1==t2)continue; f[t1]=t2;T[i]=1; add(Edge[i].x,Edge[i].y); add(Edge[i].y,Edge[i].x); &#125; dec(i,q,1)&#123; if(!d[i].id)continue; int t1=find1(d[i].x);int t2=find1(d[i].y); if(t1==t2)continue; f[t1]=t2;use[i]=1; add(d[i].x,d[i].y);add(d[i].y,d[i].x); &#125; inc(i,1,n)if(!vis[i])dfs(i,0,0); inc(i,1,m)&#123; if(T[i])continue; int x=Edge[i].x;int y=Edge[i].y; if(Find1(x)==Find1(y))continue; x=Find1(x);y=Find1(y); while(x!=y)&#123; if(dep[x]&lt;dep[y])swap(x,y); F[x]=fa[x];x=Find1(x); &#125; &#125; dec(i,q,1)&#123; if(!d[i].id)&#123; if(Find1(d[i].x)==Find1(d[i].y))S.push(1); else S.push(0); &#125; else&#123; if(use[i])continue; int x=d[i].x;int y=d[i].y; if(Find1(x)==Find1(y))continue; x=Find1(x);y=Find1(y); while(x!=y)&#123; if(dep[x]&lt;dep[y])swap(x,y); F[x]=fa[x];x=Find1(x); &#125; &#125; &#125; while(!S.empty())&#123; if(S.top())puts("Yes"); else puts("No"); S.pop(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1758(点分治+单调队列+二分)]]></title>
    <url>%2F2019%2F03%2F20%2Fbzoj1758-%E7%82%B9%E5%88%86%E6%B2%BB-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E4%BA%8C%E5%88%86%2F</url>
    <content type="text"><![CDATA[题解经典$0/1$分数规划 二分答案$ans$ 对于所有的边权减去$ans$ 问题转化成 树上是否存在一条路径 $L&lt;=len&lt;=R$ 并且路径和大于等于0 比较直观的做法 用点分+线段树查询 复杂度$O(nlog^2nlogw)$ 然而会T飞 我们考虑 每个深度对应的是一段区间 总体来看是滑动窗口 然后我们维护的是窗口里面的最大值 所以用单调队列来维护滑动过程中的区间最大值 有个优化的地方是 对于子树的枚举顺序 我们应该考虑按照子树深度递增的顺序去枚举子树 这样会保证复杂度是$O(nlognlogw)$ 否则复杂度会退化 嗯…常数很大 能过全看脸 $xjb$被卡常注意加一些比较有用的剪枝吧 复杂度$O(nlognlogw)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154// luogu-judger-enable-o2#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,double&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-4;#define ll long longusing namespace std;const int inf=1e9;struct edge&#123;int t;double v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,double vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int n,L,R;int sz[MAXN],rt,key,base,maxx[MAXN];double K;bool vis[MAXN];void get_root(int x,int pre)&#123; sz[x]=1;maxx[x]=0; link(x)&#123; if(vis[j-&gt;t]||j-&gt;t==pre)continue; get_root(j-&gt;t,x); sz[x]+=sz[j-&gt;t];maxx[x]=max(maxx[x],sz[j-&gt;t]); &#125; maxx[x]=max(maxx[x],base-sz[x]); if(key&gt;maxx[x])key=maxx[x],rt=x;&#125;double G[MAXN],H[MAXN],dis[MAXN];int dep[MAXN],St[MAXN],tot1;int Maxx;void dfs(int x,int pre)&#123; H[dep[x]]=max(H[dep[x]],dis[x]);St[++tot1]=x; Maxx=max(Maxx,dep[x]); link(x)&#123; if(vis[j-&gt;t]||j-&gt;t==pre)continue; dep[j-&gt;t]=dep[x]+1;dis[j-&gt;t]=dis[x]+j-&gt;v-K; dfs(j-&gt;t,x); &#125;&#125;int q[MAXN],ql,qr;bool flag;int Dep[MAXN];inline void get_dep(int x,int pre,int y)&#123; Dep[y]=max(Dep[y],dep[x]); link(x)&#123; if(vis[j-&gt;t]||j-&gt;t==pre)continue; dep[j-&gt;t]=dep[x]+1; get_dep(j-&gt;t,x,y); &#125;&#125;typedef struct node&#123; int x,k;double y; friend bool operator&lt;(node aa,node bb)&#123;return aa.k&lt;bb.k;&#125;&#125;node;vector&lt;node&gt;vec[MAXN];void solve1(int x)&#123; vis[x]=1; link(x)&#123; if(vis[j-&gt;t])continue; dep[j-&gt;t]=1;get_dep(j-&gt;t,x,j-&gt;t); vec[x].pb((node)&#123;j-&gt;t,Dep[j-&gt;t],j-&gt;v&#125;); &#125; sort(vec[x].begin(),vec[x].end()); link(x)&#123; if(vis[j-&gt;t])continue; Dep[j-&gt;t]=0; key=inf;base=sz[j-&gt;t];get_root(j-&gt;t,0); solve1(rt); &#125;&#125;void solve(int x)&#123; vis[x]=1;tot1=0;G[0]=0; if(flag)return ; int MAxx=0; for(int w=0;w&lt;vec[x].size();w++)&#123; int y=vec[x][w].x; Maxx=0;dep[y]=1;dis[y]=vec[x][w].y-K;dfs(y,x); int l=min(MAxx+1,max(0,L-Maxx));int r=min(MAxx,max(-1,R-Maxx));ql=1;qr=0;double ans=-inf; inc(i,l,r)&#123; while(ql&lt;=qr&amp;&amp;G[i]&gt;G[q[qr]])qr--; q[++qr]=i; &#125; dec(i,Maxx,1)&#123; int t1=min(MAxx+1,max(0,L-i));int t2=min(MAxx,max(-1,R-i)); if(t1&gt;l)&#123; while(ql&lt;=qr&amp;&amp;q[ql]&lt;t1)ql++; l=t1; &#125; if(t2&gt;r)&#123; inc(j,r+1,t2)&#123; while(ql&lt;=qr&amp;&amp;G[j]&gt;G[q[qr]])qr--; q[++qr]=j; &#125; r=t2; &#125; if(ql&lt;=qr)ans=max(ans,H[i]+G[q[ql]]); &#125; if(ans&gt;=0.000000)flag=1; MAxx=max(MAxx,Maxx); inc(i,1,Maxx)G[i]=max(G[i],H[i]),H[i]=-inf; &#125; G[0]=-inf; inc(i,1,tot1)G[dep[St[i]]]=-inf; link(x)&#123; if(vis[j-&gt;t]||L+1&gt;sz[j-&gt;t])continue; key=inf;base=sz[j-&gt;t];get_root(j-&gt;t,0); solve(rt); &#125;&#125;bool check(double x)&#123; flag=0;K=x;memset(vis,0,sizeof(vis)); base=n;key=inf;get_root(1,0); solve(rt); if(flag)return 1; return 0;&#125;int main()&#123; n=read();L=read();R=read(); int x,y;double z; inc(i,2,n)x=read(),y=read(),scanf("%lf",&amp;z),add(x,y,z),add(y,x,z); base=n;key=inf;get_root(1,0);solve1(rt); inc(i,1,n)G[i]=H[i]=-inf,vis[i]=0; double l=1.0;double r=1000000.0;double ans=0; int cnt=0; while(r-l&gt;eps)&#123; double mid=(l+r)/2.0; if(check(mid))ans=mid,l=mid; else r=mid; &#125; printf("%.3f\n",ans); return 0;&#125; 题目描述X国遭受了地震的重创, 导致全国的交通近乎瘫痪，重建家园的计划迫在眉睫。X国由N个城市组成, 重建小组提出，仅需建立N-1条道路即可使得任意两个城市互相可达。于是，重建小组很快提出了一个包含N-1条道路的方案，并满足城市之间两两可达，他们还计算评估了每条道路e建设之后可以带来的价值v(e)。 由于重建计划复杂而艰难，经费也有一定限制。因此，政府要求第一期重建工程修建的道路数目为k条，但需满足L ≤ k ≤ U, 即不应少于L条，但不超过U条。同时，为了最大化利用率，要求建设的这些道路恰好组成一条简单路径，即所建设的k条路径可以构成一个排列$e1 = (p1, q1), e2 = (p2, q2), ek = (pk, qk), 对于 1 ≤ i &lt; k, 有(qi = pi+1)$. 重建小组打算修改他们的原有方案以满足要求，即在原有的N-1条道路中寻找一条路径S作为新的方案，使得新方案中的道路平均价值 $AvgValue = \frac{\sum _{e \in S} v(e)}{|S|}​$ 最大。这里v(e)表示道路e的价值，|S|表示新方案中道路的条数。请你帮助重建小组寻找一个最优方案。 注: 在本题中L和U的设置将保证有解。 Input第一行包含一个正整数$N$，表示$X$国的城市个数。 第二行包含两个正整数$L$、$U$，表示政府要求的第一期重建方案中修建道路数的上下限。接下来的$N-1$行描述重建小组的原有方案，每行三个正整数$a_i,b_i,v_i$，分别表示道路$(a_i, b_i)$，其价值为$v_i$。其中城市由$1…N$标号。 Output仅包含一行，为一个实数$AvgValue$，即最大平均价值。 小数点后保留三位。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>点分治</tag>
        <tag>单调队列</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu5664(点分治+容斥+树状数组)]]></title>
    <url>%2F2019%2F03%2F19%2Fhdu5664-%E7%82%B9%E5%88%86%E6%B2%BB-%E5%AE%B9%E6%96%A5-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题解很牛逼的点分啊 !!!!! 我们考虑二分答案 然后直接点分统计大于等于k的点对个数 复杂度$(O(nlog^2nlogw))$ 据说卡卡常数肯定是能过的 但是我们主要用下面这种方法 我们对于当前重心的子树节点按照点到重心的距离排序 因为点只有$nlogn$个 (点分的性质) 所以预处理复杂度$O(nlog^2n)$ 其次因为你在直接计算的过程中包含了不经过当前重心的点对 所以我们需要去重 同时记录当前重心直接儿子的子树情况 做一个容斥即可.. 对于每一个二分的值 我们用双指针去统计贡献 则check复杂度为$O(nlogn)$ 对于题目另外一个条件 需要满足去掉”直链” 所以我们直接在以m为根的树中把存在$lca(u,v)=u||lca(u,v)=v$的点对删掉即可 所以总复杂度$O(nlognlogw)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=2e6+10;const int NM=2e6+10;const double eps=1e-8;const int inf=1e9;#define ll long longusing namespace std;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int n,m;ll k;int sz[MAXN],maxx[MAXN],key,rt,base,dep[MAXN];bool vis[MAXN];inline void get_root(int x,int pre)&#123; sz[x]=1;maxx[x]=0; link(x)&#123; if(vis[j-&gt;t]||j-&gt;t==pre)continue; get_root(j-&gt;t,x); sz[x]+=sz[j-&gt;t];maxx[x]=max(maxx[x],sz[j-&gt;t]); &#125; maxx[x]=max(maxx[x],base-sz[x]); if(key&gt;maxx[x])key=maxx[x],rt=x;&#125;int L[MAXN],R[MAXN],tot;int dis[MAXN],st[NM];vector&lt;pii&gt;vec[MAXN];inline void _dfs(int x,int pre)&#123; st[tot]=dis[x];tot++; link(x)&#123; if(vis[j-&gt;t]||j-&gt;t==pre)continue; dis[j-&gt;t]=dis[x]+j-&gt;v; _dfs(j-&gt;t,x); &#125;&#125;int tot1,St[NM];inline void __dfs(int x,int pre)&#123; St[tot1]=dis[x];tot1++; link(x)&#123; if(vis[j-&gt;t]||j-&gt;t==pre)continue; __dfs(j-&gt;t,x); &#125;&#125;inline void solve(int x)&#123; vis[x]=1;L[x]=tot;st[tot]=0;tot++; link(x)&#123; if(vis[j-&gt;t])continue; dis[j-&gt;t]=j-&gt;v;_dfs(j-&gt;t,x); &#125; R[x]=tot-1;sort(st+L[x],st+R[x]+1); link(x)&#123; if(vis[j-&gt;t])continue; pii t;t.first=tot1;__dfs(j-&gt;t,x); t.second=tot1-1; sort(St+t.first,St+t.second+1); vec[x].pb(t); key=inf;base=sz[j-&gt;t];get_root(j-&gt;t,0); solve(rt); &#125;&#125;inline ll calc(int l,int r,int x)&#123; if(l&gt;=r)return 0; ll ans=0; int i=l;int j=r; while(i&lt;j)&#123; while(i&lt;j&amp;&amp;st[i]+st[j]&gt;=x)ans+=r-j,j--; if(i&lt;j)ans+=max(0,r-j); i++; &#125; ans+=r-j; return ans;&#125;inline ll calc1(int l,int r,int x)&#123; if(l&gt;=r)return 0; ll ans=0; int i=l;int j=r; while(i&lt;j)&#123; while(i&lt;j&amp;&amp;St[i]+St[j]&gt;=x)ans+=r-j,j--; if(i&lt;j)ans+=max(0,r-j); i++; &#125; ans+=r-j; return ans;&#125;vector&lt;int&gt;v1;int d[NM];void dfs(int x,int pre,int y)&#123; v1.pb(d[x]);v1.pb(d[x]-y); link(x)&#123; if(j-&gt;t==pre)continue; d[j-&gt;t]=d[x]+j-&gt;v; dfs(j-&gt;t,x,y); &#125;&#125;int ans1,T;int sum[NM];int get_id(int x)&#123;return x&amp;(-x);&#125;int Get_id(int x)&#123; return lower_bound(v1.begin(),v1.begin()+T,x)-v1.begin()+1;&#125;void update(int x,int y)&#123; for(int i=x;i&lt;=T;i+=get_id(i))sum[i]+=y;&#125;int query(int x)&#123; int ans=0; for(int i=x;i&gt;0;i-=get_id(i))ans+=sum[i]; return ans;&#125;void get_sum(int x,int pre,int y)&#123; ans1+=query(Get_id(d[x]-y));update(Get_id(d[x]),1); link(x)&#123; if(j-&gt;t==pre)continue; get_sum(j-&gt;t,x,y); &#125; update(Get_id(d[x]),-1);&#125;inline bool check(int x)&#123; ll ans=0;v1.clear(); inc(i,1,n)&#123; ans+=calc(L[i],R[i],x);int size=vec[i].size(); for(int j=0;j&lt;size;j++)&#123; int t1=vec[i][j].first;int t2=vec[i][j].second; ans-=calc1(t1,t2,x); &#125; &#125; dfs(m,0,x);sort(v1.begin(),v1.end()); T=unique(v1.begin(),v1.end())-v1.begin(); ans1=0;get_sum(m,0,x);ans-=ans1; if(ans&gt;=k)return 1; return 0;&#125;int main()&#123; int _=read(); while(_--)&#123; tot=tot1=1;memset(h,0,sizeof(h));o=e; n=read();m=read();k=read(); int x,y,z; inc(i,2,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); key=inf;base=n;get_root(1,0); solve(rt); int l=1;int r=6e8;int ans=0; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(check(mid))ans=mid,l=mid+1; else r=mid-1; &#125; if(!ans)puts("NO"); else printf("%d\n",ans); inc(i,1,n)vec[i].clear(),vis[i]=0,d[i]=L[i]=R[i]=0; &#125; return 0;&#125; 题目描述Lady CA has a tree with n points numbered $1,2,…,n$, and each edge has its weight. The unique route connecting two points is called a chain, and the length of a chain equals the sum value of the weights of the edges passed. The point number m is called the root. Lady CA defines a special kind of chain called folded chain, the chain connecting the points numbered $x,y(x≠y)$ is called a folded chain, if and only if the chain connecting the point numbered $x$ and the root doesn’t pass the point numbered $y$, and the chain connecting the point numbered yand the root doesn’t pass the point numbered $x$. Lady CA wants to find the length of the $kth$ longest folded chain. Notice that the chain connecting the points numbered $x,y$ and the chain connecting the points numbered $y$,$x$ are the same. InputThe first line contains an integer $T(1≤T≤3)$——The number of the test cases. For each test case:The first line contains three integers $n(2≤n≤50,000),m(1≤m≤n),k(1≤k≤n×(n−1)/2)$. Between each two adjacent integers there is a white space separated.The second line to the nth line describes the $n−1$ edges in the graph. Each line contains three integers $u,v(1≤u,v≤n,u≠v),w(1≤w≤10,000)$, which means there is an edge which has a weight $w$ connecting the points numbered $u,v$. Between each two adjacent integers there is a white space separated. OutputFor each test case, the only line contains the only integer that is the length of the $kth$ longest folded chain. If the $kth$ longest folded chain doesn’t exist, print $NO$.]]></content>
      <categories>
        <category>数据结构</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>点分治</tag>
        <tag>树状数组</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj4598(点分治+hash)]]></title>
    <url>%2F2019%2F03%2F19%2Fbzoj4598-%E7%82%B9%E5%88%86%E6%B2%BB-hash%2F</url>
    <content type="text"><![CDATA[题解点对问题考虑点分 我们考虑子树合并 有两种情况 分别是当前子树链作为开头或者结尾 对于长度大于$m$和小于等于$m$再分情况讨论下 然后分别维护已经合并完的子树在长度为$x$时 分别作为开头和结尾的情况下的方案数 统计贡献的话 就直接用hash判当前的子串是否合法即可 hash我们考虑自然溢出 时间复杂度 $O(nlogn)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=H1[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=1e6+10;const double eps=1e-8;#define ll long longconst int inf=1e9;using namespace std;struct edge&#123;int t;edge*next;&#125;e[MAXN&lt;&lt;1],*H1[MAXN],*o=e;void add(int x,int y)&#123;o-&gt;t=y;o-&gt;next=H1[x];H1[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;char str[MAXN],s[MAXN];int n,m;int sz[MAXN],maxx[MAXN],key,rt,base;bool vis[MAXN];void get_root(int x,int pre)&#123; sz[x]=1;maxx[x]=0; link(x)&#123; if(vis[j-&gt;t]||j-&gt;t==pre)continue; get_root(j-&gt;t,x); sz[x]+=sz[j-&gt;t];maxx[x]=max(maxx[x],sz[j-&gt;t]); &#125; maxx[x]=max(maxx[x],base-sz[x]); if(key&gt;maxx[x])key=maxx[x],rt=x;&#125;int g[MAXN],h[MAXN],g1[MAXN],h1[MAXN];//g 表示开头 h表示结尾unsigned long long sum[MAXN],dis[MAXN],Dep[MAXN],ma[MAXN],sum1[MAXN];int dep[MAXN];ll ans;bool G[MAXN],H[MAXN];int st[MAXN],tot,St[MAXN],tot1;void dfs(int x,int pre)&#123; Dep[dep[x]]=dis[x]; if(dep[x]&lt;=m)&#123; if(dis[x]==sum[dep[x]])G[dep[x]]=1,ans+=h[m-dep[x]],g1[dep[x]-1]++; if(dis[x]*ma[m-dep[x]]==sum1[m]-sum1[m-dep[x]])H[dep[x]]=1,ans+=g[m-dep[x]],h1[dep[x]-1]++; st[++tot]=dep[x]-1;St[++tot1]=dep[x]-1; &#125; else&#123; if(G[dep[x]-m]&amp;&amp;dis[x]-Dep[dep[x]-m]==ma[dep[x]-m]*sum[m])G[dep[x]]=1,ans+=h[(m-dep[x]%m)%m],g1[(dep[x]%m-1+m)%m]++; if(H[dep[x]-m]&amp;&amp;dis[x]-Dep[dep[x]-m]==ma[dep[x]-m]*sum1[m])H[dep[x]]=1,ans+=g[(m-dep[x]%m)%m],h1[(dep[x]%m-1+m)%m]++; st[++tot]=(dep[x]%m-1+m)%m;St[++tot1]=(dep[x]%m-1+m)%m; &#125; link(x)&#123; if(vis[j-&gt;t]||j-&gt;t==pre)continue; dep[j-&gt;t]=dep[x]+1; dis[j-&gt;t]=dis[x]+ma[dep[j-&gt;t]-1]*str[j-&gt;t]; dfs(j-&gt;t,x); &#125; G[dep[x]]=H[dep[x]]=0;&#125;void solve(int x)&#123; vis[x]=1;tot1=0;g[0]=h[0]=1;dis[x]=str[x];Dep[1]=dis[x]; if(str[x]==s[m])H[1]=1; if(str[x]==s[1])G[1]=1; link(x)&#123; if(vis[j-&gt;t])continue; tot=0;dep[j-&gt;t]=2;dis[j-&gt;t]=dis[x]+ma[dep[j-&gt;t]-1]*str[j-&gt;t];dfs(j-&gt;t,x); inc(i,1,tot)g[st[i]]+=g1[st[i]],g1[st[i]]=0,h[st[i]]+=h1[st[i]],h1[st[i]]=0; &#125; inc(i,1,tot1)g[St[i]]=h[St[i]]=0; g[0]=h[0]=0; link(x)&#123; if(vis[j-&gt;t])continue; key=inf;base=sz[j-&gt;t];get_root(j-&gt;t,0); solve(rt); &#125;&#125;int main()&#123; int _=read();ma[0]=1; inc(i,1,1e6)ma[i]=ma[i-1]*131; while(_--)&#123; memset(H1,0,sizeof(H1));o=e; n=read();m=read(); inc(i,1,n)vis[i]=0; scanf("%s",str+1); int x,y;ans=0; inc(i,2,n)x=read(),y=read(),add(x,y),add(y,x); scanf("%s",s+1); inc(i,1,m)sum[i]=sum[i-1]*131+s[i],sum1[i]=sum1[i-1]+ma[i-1]*s[i]; key=inf;base=n;get_root(1,0); solve(rt); printf("%lld\n",ans); &#125; return 0;&#125; 题目描述给出$n$个结点的树结构$T$，其中每一个结点上有一个字符，这里我们所说的字符只考虑大写字母$A$到$Z$,再给出长度为$m$的模式串$s$，其中每一位仍然是$A$到$Z$的大写字母。$Alice$希望知道，有多少对结点$&lt;u,v&gt;$满足$T$上从$U$到$V$的最短路径形成的字符串可以由模式串$S$重复若干次得到？这里结点对$&lt;u,v&gt;$是有序的，也就是说$&lt;u,v&gt;和&lt;v,u&gt;$需要被区分.所谓模式串的重复，是将若干个模式串$S$依次相接（不能重叠).例如当$S=PLUS$的时候，重复两次会得到$PLUSPLUS$，重复三次会得到$PLUSPLUSPLUS$,同时要注恿，重复必须是整数次的。例如当S=$XYXY$时，因为必须重复整数次，所以$XYXYXY$不能看作是$S$重复若干次得到的。 Input每一个数据有多组测试， 第一行输入一个整数$C$，表示总的测试个数。 对于每一组测试来说： 第一行输入两个整数，分别表示树$T$的结点个数$n$与模式长度$m$。结点被依次编号为$1$到$n$，之后一行，依次给出了$n$个大写字母（以一个长度为$n$的字符串的形式给出），依次对应树上每一个结点上的字符（第$i$个字符对应了第$i$个结点).之后$n-1$行，每行有两个整数$u$和$v$表示树上的一条无向边，之后一行给定一个长度为$m$的由大写字母组成的字符串，为模式串$S$。 $1&lt;=C&lt;=10,3&lt;=N&lt;=10^6,3&lt;=M&lt;=10^6$ Output给出$C$行，对应$C$组测试。每一行输出一个整数，表示有多少对节点$&lt;u,v&gt;$满足从$u$到$v$的路径形成的字符串恰好是模式串的若干次重复.]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>点分治</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj3648(点分治+树状数组)]]></title>
    <url>%2F2019%2F03%2F15%2Fbzoj3648-%E7%82%B9%E5%88%86%E6%B2%BB-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题解分为两部分 对于树形结构 直接点分 然后排序/树状数组统计贡献 对于基环树结构 我们先把环取出来 以环上的点为根做点分治 统计每个子树内的贡献 然后考虑环上点的相互影响 对于每个子树维护每种深度的个数 然后我们可以考虑到每个点作用的是一段连续区间 可以采用树状数组来维护答案 时间复杂度是$O(nlogn)$ 至于环上点的维护 就是变环为链 然后维护即可 时间复杂度 $O(nlog^2n)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;#define ll long longusing namespace std;const int inf=1e9;struct edge&#123;int t;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y)&#123;o-&gt;t=y;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125; int n,m,k;int st[MAXN],tot,num[MAXN];bool vis[MAXN];vector&lt;int&gt;vec;ll ans;int f[MAXN],fa[MAXN];int find1(int x)&#123; if(x==f[x])return x; return f[x]=find1(f[x]);&#125; int rt,key,maxx[MAXN],sz[MAXN],base; void get_root(int x,int pre)&#123; sz[x]=1;maxx[x]=0; link(x)&#123; if(vis[j-&gt;t]||j-&gt;t==pre)continue; get_root(j-&gt;t,x); sz[x]+=sz[j-&gt;t];maxx[x]=max(maxx[x],sz[j-&gt;t]); &#125; maxx[x]=max(maxx[x],base-sz[x]); if(key&gt;maxx[x])key=maxx[x],rt=x;&#125;int dis[MAXN];int get_id(int x)&#123;return x&amp;(-x);&#125;int sum[MAXN];void update(int x,int y)&#123; for(int i=x;i&lt;=n;i+=get_id(i))sum[i]+=y;&#125;void clear(int x)&#123; for(int i=x;i&lt;=n;i+=get_id(i))sum[i]=0;&#125;int Sum(int x)&#123; int ans1=0; for(int i=x;i&gt;0;i-=get_id(i))ans1+=sum[i]; return ans1;&#125; int St[MAXN],tot1;void _dfs(int x,int pre)&#123; if(dis[x]&lt;=k)ans+=Sum(n)-Sum(k-dis[x]);else ans+=Sum(n); st[++tot]=x;St[++tot1]=x; link(x)&#123; if(vis[j-&gt;t]||j-&gt;t==pre)continue; dis[j-&gt;t]=dis[x]+1; _dfs(j-&gt;t,x); &#125;&#125; void solve(int x)&#123; vis[x]=1;tot1=0;update(1,1); link(x)&#123; if(vis[j-&gt;t])continue; tot=0;dis[j-&gt;t]=2;_dfs(j-&gt;t,x); inc(i,1,tot)update(dis[st[i]],1); &#125; inc(i,1,tot1)clear(dis[St[i]]); clear(1); link(x)&#123; if(vis[j-&gt;t])continue; key=inf;base=sz[j-&gt;t];get_root(j-&gt;t,0); solve(rt); &#125;&#125; int dep[MAXN];int qko[MAXN];void update1(int x,int y)&#123; for(int i=x;i&lt;=3*n;i+=get_id(i))qko[i]+=y;&#125;int Sum1(int x)&#123; int ans1=0; for(int i=x;i&gt;0;i-=get_id(i))ans1+=qko[i]; return ans1;&#125; int Maxx;void __dfs(int x,int pre,int deep)&#123; dep[deep]++;Maxx=max(Maxx,deep); link(x)&#123; if(vis[j-&gt;t]||j-&gt;t==pre)continue; __dfs(j-&gt;t,x,deep+1); &#125;&#125; typedef struct node&#123; int x,y;&#125;node;node que[MAXN]; int Num[MAXN];vector&lt;int&gt;Vec[MAXN];void dfs(int x,int pre)&#123; fa[x]=pre; for(int i=0;i&lt;Vec[x].size();i++)&#123; if(Vec[x][i]==pre)continue; dfs(Vec[x][i],x); &#125;&#125; int main()&#123; n=read();m=read();k=read(); int x,y; inc(i,1,n)f[i]=i; inc(i,1,m)x=read(),y=read(),add(x,y),add(y,x),que[i]=(node)&#123;x,y&#125;; x=0;y=0; inc(i,1,m)&#123; int t1=find1(que[i].x);int t2=find1(que[i].y); if(t1==t2)&#123;x=que[i].x;y=que[i].y;continue;&#125; Vec[que[i].x].pb(que[i].y); Vec[que[i].y].pb(que[i].x); f[t1]=t2; &#125; if(x)&#123; dfs(1,0); int root; int x1=x;int y1=y; while(x)Num[x]++,x=fa[x]; while(y)&#123; if(Num[y])&#123;root=y;break;&#125; y=fa[y]; &#125; x=x1;y=y1; while(x!=root)vec.pb(x),x=fa[x]; vec.pb(root);int t=vec.size(); while(y!=root)vec.pb(y),y=fa[y]; reverse(vec.begin()+t,vec.end()); &#125; inc(i,1,n)vis[i]=0; int t=vec.size(); ans=0; if(t)&#123; inc(i,0,t-1)vis[vec[i]]=1; inc(i,0,t-1)&#123; vis[vec[i]]=0; base=num[vec[i]];key=inf;get_root(vec[i],0); solve(rt); vis[vec[i]]=1; &#125; inc(i,1,n)vis[i]=0; inc(i,0,t-1)vis[vec[i]]=1; vis[vec[0]]=0;Maxx=0;__dfs(vec[0],0,1);vis[vec[0]]=1; inc(i,0,t-2)vec.pb(vec[i]); inc(i,1,Maxx)&#123; int l=max(1,k+1-i);int r=1+t; update1(l,dep[i]); dep[i]=0; &#125; for(int i=1;i&lt;vec.size();i++)&#123; vis[vec[i]]=0;Maxx=0;__dfs(vec[i],0,1);vis[vec[i]]=1; inc(j,1,Maxx)&#123; int l=max(i+1,k+i+1-j-t); if(i&gt;=t)update1(l,-dep[j]); &#125; inc(j,1,Maxx)&#123; int pos=i+j; ans+=1ll*Sum1(pos)*dep[j]; &#125; inc(j,1,Maxx)&#123; int l=max(i+1,k+i+1-j); if(i&lt;t)update1(l,dep[j]); dep[j]=0; &#125; &#125; printf("%lld\n",ans); &#125; else&#123; base=n;key=inf;get_root(1,0); solve(rt); printf("%lld\n",ans); &#125; return 0;&#125; 题目描述T64有一个好朋友，叫T128。T128是寄宿生，并且最近被老师叫过去当宿管了。宿管可不是一件很好做的工作，碰巧T128有一个工作上的问题想请T64帮忙解决。T128的寝室条件不是很好，所以没有很多钱来装修。礼间寝室仅由$n-1$条双向道路连接，而且任意两间寝室之间都可以互达。最近，T128被要求对一条路径上的所有寝室进行管理，这条路径不会重复经过某个点或某条边。但他不记得是哪条路径了。他只记得这条路径上有不少于$k$个寝室。于是，他想请T64帮忙数一下，有多少条这样的路径满足条件。嗯…还有一个问题。由于最近有一些熊孩子不准晚上讲话很不爽，他们决定修筑一条“情报通道”，如果通道建成，寝室就变成了一个$N$个点$N$条边的无向图。并且，经过“情报通道”的路径也是合法的。T128心想：通道建成之前，T64还有一个高效的算法帮我数路径条数，但是通道建成之后，他还有办法吗？对，T64手忙脚乱，根本数不清有多少条路径。于是他找到了你。 Input第一行为三个正整数$N$，$M$，$K（2 ≤ K ≤ N）$，代表有$n$间寝室，$m$条边连接它们$n-1 ≤ m ≤ N$； $m= n-1$意味着“情报遁道”未被修好；$m=n$意味着“情报通道”已被修好），以及题目描述中的$K$。 接下来$m$行，每行两个正整数$z$，$y$，代表第$x$间寝室与第$y$间寝室之间有一条双向边。 Output仅包含一个整数，代表经过至少$K$间寝室的路径条数。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>点分治</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj2870(点分治+树状数组)]]></title>
    <url>%2F2019%2F03%2F15%2Fbzoj2870-%E7%82%B9%E5%88%86%E6%B2%BB-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题解(下文子树权值是指当前点到重心节点路径的最小值) 摁….卡线段树….选择树状数组吧(树状数组下标是权值 维护前缀区间路径长度的最大值) 因为是点对问题….点分治没跑了 我们考虑子树合并 对于大于当前结点权值的点 我们可以在$O(logn)$的情况下得到答案 但是对于小于当前权值的点我们没有比较高效的办法统计贡献 但是我们可以反着跑一遍 就能维护所有的答案了 时间复杂度 $O(nlog^2n)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;#define ll long longconst int inf=1e9;using namespace std;struct edge&#123;int t;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y)&#123;o-&gt;t=y;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125; int N,n,a[MAXN],base,key,rt,sz[MAXN],maxx[MAXN];int ans2[MAXN];bool vis[MAXN];ll ANS; int get_id(int x)&#123;return x&amp;(-x);&#125;void update(int x,int t)&#123; for(int i=x;i&lt;=N;i+=get_id(i))ans2[i]=max(ans2[i],t);&#125;int query(int x)&#123; int ans=0; for(int i=x;i&gt;0;i-=get_id(i))ans=max(ans,ans2[i]); return ans;&#125; void clear(int x)&#123; for(int i=x;i&lt;=N;i+=get_id(i))ans2[i]=0;&#125; void get_root(int x,int pre)&#123; sz[x]=1;maxx[x]=0; link(x)&#123; if(vis[j-&gt;t]||j-&gt;t==pre)continue; get_root(j-&gt;t,x); sz[x]+=sz[j-&gt;t];maxx[x]=max(maxx[x],sz[j-&gt;t]); &#125; maxx[x]=max(maxx[x],base-sz[x]); if(key&gt;maxx[x])key=maxx[x],rt=x;&#125; int num[MAXN],dis[MAXN];int st[MAXN],tot,St[MAXN],tot1,ans1;void dfs(int x,int pre)&#123; ans1=query(N-dis[x]+1); if(ans1)ANS=max(ANS,1ll*(ans1+num[x]-1)*(dis[x]-1)),st[++tot]=x; link(x)&#123; if(vis[j-&gt;t]||j-&gt;t==pre)continue; num[j-&gt;t]=num[x]+1;dis[j-&gt;t]=min(dis[x],a[j-&gt;t]); dfs(j-&gt;t,x); &#125;&#125; int p[MAXN],cnt;void solve(int x)&#123; vis[x]=1;tot1=0;cnt=0; update(N-a[x]+1,1); link(x)&#123; if(vis[j-&gt;t])continue; p[++cnt]=j-&gt;t; tot=0;num[j-&gt;t]=2;dis[j-&gt;t]=min(a[j-&gt;t],a[x]);dfs(j-&gt;t,x); inc(i,1,tot)update(N-dis[st[i]]+1,num[st[i]]),St[++tot1]=st[i]; &#125; inc(i,1,tot1)clear(N-dis[St[i]]+1); update(N-a[x]+1,1); dec(i,cnt,1)&#123; tot=0;num[p[i]]=2;dis[p[i]]=min(a[p[i]],a[x]);dfs(p[i],x); inc(j,1,tot)update(N-dis[st[j]]+1,num[st[j]]); &#125; inc(i,1,tot1)clear(N-dis[St[i]]+1); clear(N-a[x]+1); link(x)&#123; if(vis[j-&gt;t])continue; key=inf;base=sz[j-&gt;t];get_root(j-&gt;t,0); solve(rt); &#125;&#125; int main()&#123; n=read(); inc(i,1,n)a[i]=read()+1,N=max(N,a[i]),ANS=max(ANS,1ll*(a[i]-1)); int x,y; inc(i,2,n)x=read(),y=read(),add(x,y),add(y,x); key=inf;base=n;get_root(1,0); solve(rt); printf("%lld\n",ANS); return 0;&#125; 题目描述给定一棵$N$个点的树，求树上一条链使得链的长度乘链上所有点中的最小权值所得的积最大。 其中链长度定义为链上点的个数。 Input第一行$N$ 第二行$N$个数分别表示$1~N$的点权$v[i]$ 接下来$N-1$行每行两个数$x$、$y$，表示一条连接$x$和$y$的边 Output一个数，表示最大的痛苦程度。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>点分治</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj3784(点分治)]]></title>
    <url>%2F2019%2F03%2F13%2Fbzoj3784-%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[题解这题确实妙妙秒啊!!!!! 首先这是一个点对问题 我们还是从点分入手 仍然考虑子树点对 我们发现对于当前子树 能与其组成点对的是同一个重心的情况下之前的子树 考虑到类似dfs序的东西 我们称之为点分序吧 所以我们能把这个树形问题转化为序列问题 因为点分的性质保证每个点最多出现$logn$次 那么对于这$nlogn$个节点 每个点的权值对应的是其到重心的距离 且每个节点都具有一个管辖区间$[L,R]$ 表示的是当前点能与这个区间的点能组合成点对. 经过上述的转化 我们可以类似于 超级钢琴的做法 用$st$表查询区间最大值的位置 以及 用堆维护前$m$大的元素即可 复杂度 $O(mlogn+nlogn)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=6e4+10;const int NM=8e5+10;const double eps=1e-8;#define ll long longconst int inf=1e9;using namespace std;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int n;ll m;int key,rt,maxx[MAXN],sz[MAXN],base;bool vis[MAXN];int tot,pos[NM][18],dp[NM];int L[NM],R[NM],ma[NM];void get_root(int x,int pre)&#123; maxx[x]=0;sz[x]=1; link(x)&#123; if(j-&gt;t==pre||vis[j-&gt;t])continue; get_root(j-&gt;t,x); sz[x]+=sz[j-&gt;t];maxx[x]=max(maxx[x],sz[j-&gt;t]); &#125; maxx[x]=max(maxx[x],base-sz[x]); if(key&gt;maxx[x])key=maxx[x],rt=x;&#125;int dis[MAXN];int l,r;void dfs(int x,int pre)&#123; tot++; pos[tot][0]=tot; dp[tot]=dis[x];L[tot]=l;R[tot]=r; link(x)&#123; if(vis[j-&gt;t]||j-&gt;t==pre)continue; dis[j-&gt;t]=dis[x]+j-&gt;v; dfs(j-&gt;t,x); &#125;&#125;void solve(int x)&#123; vis[x]=1;tot++; pos[tot][0]=tot;dp[tot]=0;L[tot]=tot;R[tot]=tot; l=tot;r=tot; link(x)&#123; if(vis[j-&gt;t])continue; dis[j-&gt;t]=j-&gt;v;dfs(j-&gt;t,x); r=tot; &#125; link(x)&#123; if(vis[j-&gt;t])continue; key=inf;base=sz[j-&gt;t];get_root(j-&gt;t,0); solve(rt); &#125;&#125;void St()&#123; inc(i,2,tot)ma[i]=ma[i/2]+1; inc(j,1,17)&#123; for(int i=1;i+(1&lt;&lt;j)&lt;=tot+1;i++)&#123; if(dp[pos[i][j-1]]&gt;=dp[pos[i+(1&lt;&lt;(j-1))][j-1]])pos[i][j]=pos[i][j-1]; else pos[i][j]=pos[i+(1&lt;&lt;(j-1))][j-1]; &#125; &#125;&#125;int rmq(int l,int r)&#123; if(l&gt;r)return 0; int k=ma[r-l+1]; if(dp[pos[l][k]]&gt;=dp[pos[r-(1&lt;&lt;k)+1][k]])return pos[l][k]; else return pos[r-(1&lt;&lt;k)+1][k];&#125;typedef struct node&#123; int l,r,pos,id,k; friend bool operator&lt;(node aa,node bb)&#123;return aa.k&lt;bb.k;&#125;&#125;node;priority_queue&lt;node&gt;que;int main()&#123; n=read();m=read(); int x,y,z;tot=0; m=min(m,1ll*n*(n-1)/2); inc(i,2,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); base=n;key=inf;get_root(1,0); solve(rt); St(); inc(i,1,tot)&#123; int t=rmq(L[i],R[i]); que.push((node)&#123;L[i],R[i],t,i,dp[t]+dp[i]&#125;); &#125; inc(i,1,m)&#123; printf("%d\n",(que.top()).k); node p=que.top();que.pop(); int t1=rmq(p.l,p.pos-1); int t2=rmq(p.pos+1,p.r); if(t1)que.push((node)&#123;p.l,p.pos-1,t1,p.id,dp[p.id]+dp[t1]&#125;); if(t2)que.push((node)&#123;p.pos+1,p.r,t2,p.id,dp[p.id]+dp[t2]&#125;); &#125; return 0;&#125; 题目描述给定一个$N$个结点的树，结点用正整数$1..N$编号。每条边有一个正整数权值。用$d(a,b)$表示从结点$a$到结点$b$路边上经过边的权值。其中要求$a&lt;b$.将这$n*(n-1)/2$个距离从大到小排序，输出前$M$个距离值。 Input第一行两个正整数$N,M$ 下面$N-1$行，每行三个正整数$a,b,c(a,b&lt;=N,C&lt;=10000).$表示结点$a$到结点$b$有一条权值为$c$的边。 Output共$M$行，如题所述.]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>点分治</tag>
        <tag>堆</tag>
        <tag>st表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj4016(点分治)]]></title>
    <url>%2F2019%2F03%2F13%2Fbzoj4016-%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[题解:强行凑题….. 前面构造最短路树 然后后半部分模板点分统计贡献 这个最短路树要保证路径的字典序最小 那么我们可以跑出最短路 枚举边 看距离差值是否等于边权 然后连边 对于所有连边排序以后 做$dfs$建树 第二部分就直接考虑子树合并 维护每个深度下的最大距离 以及方案数 枚举统计贡献 复杂度 $O(mlogn+nlogn)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=1e5+10;const double eps=1e-8;#define ll long longusing namespace std;const ll inf=1e12;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int n,m,k;vector&lt;pii&gt;vec[MAXN];ll dis[MAXN],ans1;ll ans2;bool vis[MAXN];typedef struct Node&#123; int x,y,z;&#125;Node;Node Edge[MAXN];typedef struct node&#123; int v;ll d; friend bool operator&lt;(node aa,node bb)&#123; return aa.d&gt;bb.d; &#125;&#125;node;priority_queue&lt;node&gt;que;void dij(int s)&#123; inc(i,1,n)vis[i]=0,dis[i]=inf; dis[s]=0;que.push((node)&#123;s,0&#125;); while(!que.empty())&#123; node t=que.top();que.pop(); if(vis[t.v])continue; vis[t.v]=1; link(t.v)&#123; if(dis[j-&gt;t]&gt;dis[t.v]+j-&gt;v)&#123; dis[j-&gt;t]=dis[t.v]+j-&gt;v; que.push((node)&#123;j-&gt;t,dis[j-&gt;t]&#125;); &#125; &#125; &#125; for(int i=1;i&lt;=m;i++)&#123; int x=Edge[i].x;int y=Edge[i].y; if(dis[x]&gt;dis[y])swap(x,y); if(Edge[i].z==dis[y]-dis[x])vec[x].pb(mp(y,Edge[i].z)); &#125;&#125;void dfs(int x)&#123; vis[x]=1; for(int i=0;i&lt;vec[x].size();i++)&#123; if(vis[vec[x][i].first])continue; add(x,vec[x][i].first,vec[x][i].second); add(vec[x][i].first,x,vec[x][i].second); dfs(vec[x][i].first); &#125;&#125;int rt,sz[MAXN],maxx[MAXN],base;int key;void get_root(int x,int pre)&#123; sz[x]=1;maxx[x]=0; link(x)&#123; if(vis[j-&gt;t]||j-&gt;t==pre)continue; get_root(j-&gt;t,x); sz[x]+=sz[j-&gt;t];maxx[x]=max(maxx[x],sz[j-&gt;t]); &#125; maxx[x]=max(maxx[x],base-sz[x]); if(key&gt;maxx[x])rt=x,key=maxx[x];&#125;int c1[MAXN];ll MAxx[MAXN];int num[MAXN];int st[MAXN],St[MAXN],tot,tot1;void _dfs(int x,int pre)&#123; num[x]=num[pre]+1; if(num[x]&gt;k)return ; st[++tot]=x,St[++tot1]=x; link(x)&#123; if(vis[j-&gt;t]||j-&gt;t==pre)continue; dis[j-&gt;t]=dis[x]+j-&gt;v; _dfs(j-&gt;t,x); &#125;&#125;void solve(int x)&#123; vis[x]=1;tot1=0;c1[1]=1;MAxx[1]=0; link(x)&#123; if(vis[j-&gt;t])continue; tot=0;num[x]=1;dis[j-&gt;t]=j-&gt;v;_dfs(j-&gt;t,x); inc(i,1,tot)&#123; if(dis[st[i]]+MAxx[k+1-num[st[i]]]&gt;ans1)ans1=dis[st[i]]+MAxx[k+1-num[st[i]]],ans2=c1[k+1-num[st[i]]]; else if(dis[st[i]]+MAxx[k+1-num[st[i]]]==ans1)ans2+=c1[k+1-num[st[i]]]; &#125; inc(i,1,tot)&#123; if(MAxx[num[st[i]]]==dis[st[i]])c1[num[st[i]]]++; else if(MAxx[num[st[i]]]&lt;dis[st[i]])MAxx[num[st[i]]]=dis[st[i]],c1[num[st[i]]]=1; &#125; &#125; inc(i,1,tot1)MAxx[num[St[i]]]=-inf,c1[num[St[i]]]=0; c1[1]=0;MAxx[1]=-inf; link(x)&#123; if(vis[j-&gt;t])continue; base=sz[j-&gt;t];key=(1&lt;&lt;30);get_root(j-&gt;t,0); solve(rt); &#125;&#125;int main()&#123; n=read();m=read();k=read(); inc(i,0,n)MAxx[i]=-inf; int x,y,z; inc(i,1,m)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z),Edge[i]=(Node)&#123;x,y,z&#125;; dij(1); memset(h,0,sizeof(h));memset(e,0,sizeof(e));o=e; inc(i,1,n)vis[i]=dis[i]=0; inc(i,1,n)sort(vec[i].begin(),vec[i].end()); dfs(1); inc(i,1,n)vis[i]=0; key=(1&lt;&lt;30);base=n;get_root(1,0); solve(rt); printf("%lld %lld\n",ans1,ans2); return 0;&#125; 题目描述给一个包含$n$个点，$m$条边的无向连通图。从顶点$1$出发，往其余所有点分别走一次并返回。 往某一个点走时，选择总长度最短的路径走。若有多条长度最短的路径，则选择经过的顶点序列字典序最小的那条路径(如路径A为$1,32,11，$路径B为$1,3,2,11$，路径B字典序较小。注意是序列的字典序的最小，而非路径中节点编号相连的字符串字典序最小)。到达该点后按原路返回，然后往其他点走，直到所有点都走过。 可以知道，经过的边会构成一棵最短路径树。请问，在这棵最短路径树上，最长的包含K个点的简单路径长度为多长？长度为该最长长度的不同路径有多少条？ 这里的简单路径是指：对于一个点最多只经过一次的路径。不同路径是指路径两端端点至少有一个不同，点A到点B的路径和点B到点A视为同一条路径 Input第一行输入三个正整数$n,m，K$，表示有$n$个点$m$条边，要求的路径需要经过$K$个点。接下来输入$m$行，每行三个正整数$A_i,B_i,C_i(1&lt;=A_i,B_i&lt;=n,1&lt;=C_i&lt;=10000)$，表示$A_i$和$B_i$间有一条长度为$C_i$的边。数据保证输入的是连通的无向图。 Output输出一行两个整数，以一个空格隔开，第一个整数表示包含$K$个点的路径最长为多长，第二个整数表示这样的不同的最长路径有多少条。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj3697(点分治)]]></title>
    <url>%2F2019%2F03%2F12%2Fbzoj3697-%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[题解:这题稍微有点绕 如果我们仅仅只要查询一段路径的上$0/1$路径段的数量相等的话 直接做点分就行了 但是现在需要存在一个中间转折点 要这个点到两段的$0/1$路径的数量段同样相等 所以我们考虑每个点到重心节点的$0/1$数量段的差值 我们根据节点之前的祖先节点是否出现和其一样差值的节点将其分成两类 然后分类讨论下 若当前这点属于前面有相同祖先节点具有相同差值的情况 那么他能和其他不同子树上任意一类节点产生贡献 若属于后者 那么他只能和其他不同子树中的第一类节点产生贡献 然后注意下细节就$OK$了 时间复杂度 $O(nlogn)$ 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;#define ll long longusing namespace std;const int inf=1e9;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int n,key,rt,base;int sz[MAXN],maxx[MAXN];int dp1[MAXN&lt;&lt;1],dp2[MAXN&lt;&lt;1],dis[MAXN],Vis[MAXN&lt;&lt;2];bool vis[MAXN];ll ans;void get_root(int x,int pre)&#123; sz[x]=1;maxx[x]=0; link(x)&#123; if(j-&gt;t==pre||vis[j-&gt;t])continue; get_root(j-&gt;t,x); sz[x]+=sz[j-&gt;t];maxx[x]=max(maxx[x],sz[j-&gt;t]); &#125; maxx[x]=max(maxx[x],base-sz[x]); if(key&gt;maxx[x])key=maxx[x],rt=x;&#125;int tot,St[MAXN],tot1;pii st[MAXN];void dfs(int x,int pre)&#123; St[++tot1]=dis[x]; //cout&lt;&lt;x&lt;&lt;":: "&lt;&lt;pre&lt;&lt;" "&lt;&lt;dis[x]&lt;&lt;endl; if(Vis[dis[x]+n])ans+=dp1[n-dis[x]],ans+=dp2[n-dis[x]],st[++tot]=mp(dis[x],1); else ans+=dp2[n-dis[x]],st[++tot]=mp(dis[x],2); if(!dis[x]&amp;&amp;Vis[n])ans++; if(!dis[x]&amp;&amp;!Vis[n])ans+=dp1[n]; Vis[dis[x]+n]++; // cout&lt;&lt;x&lt;&lt;"::: "&lt;&lt;dis[x]&lt;&lt;" "&lt;&lt;ans&lt;&lt;endl; link(x)&#123; if(j-&gt;t==pre||vis[j-&gt;t])continue; dis[j-&gt;t]=dis[x]+(j-&gt;v==0?1:-1); dfs(j-&gt;t,x); &#125; Vis[dis[x]+n]--;&#125;void solve(int x)&#123; vis[x]=1;tot1=0; link(x)&#123; if(vis[j-&gt;t])continue; tot=0;dis[j-&gt;t]=(j-&gt;v==0?1:-1);dfs(j-&gt;t,x); inc(i,1,tot)if(st[i].second==1)dp2[n+st[i].first]++;else dp1[n+st[i].first]++; &#125; inc(i,1,tot1)dp1[n+St[i]]=dp2[n+St[i]]=0; link(x)&#123; if(vis[j-&gt;t])continue; key=inf;base=sz[j-&gt;t];get_root(j-&gt;t,0); solve(rt); &#125;&#125;int main()&#123; n=read(); int x,y,z; ans=0; inc(i,2,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); key=inf;base=n;get_root(1,0); solve(rt); printf("%lld\n",ans); return 0;&#125; 题目描述采药人的药田是一个树状结构，每条路径上都种植着同种药材。采药人以自己对药材独到的见解，对每种药材进行了分类。大致分为两类，一种是阴性的，一种是阳性的。采药人每天都要进行采药活动。他选择的路径是很有讲究的，他认为阴阳平衡是很重要的，所以他走的一定是两种药材数目相等的路径。采药工作是很辛苦的，所以他希望他选出的路径中有一个可以作为休息站的节点（不包括起点和终点），满足起点到休息站和休息站到终点的路径也是阴阳平衡的。他想知道他一共可以选择多少种不同的路径。 Input第$1$行包含一个整数$N$。接下来$N-1$行，每行包含三个整数$a_i b_i t_i$,表示这条路上药材的类型。 Output输出符合采药人要求的路径数目。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1316(点分治)]]></title>
    <url>%2F2019%2F03%2F12%2Fbzoj1316-%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[题解第一眼以为$q$很大…想了一晚上…. 然后早上起来看题….$q&lt;=100$ 惊了 好了 言归正传 $q&lt;=100$那就直接暴力跑100次点分$ check $ 据说这样会被卡常数???反正我没试过 我们考虑 直接在重心分治的时候$check$ 每次把新的子树合并上去 然后$q$次$check$对应的$len$是否存在 然后我很快就$WA$了 原因是因为 $len=0$ 这种情况存在 特判下就能A了 复杂度 $O(qnlogn)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const int NM=1e6+10;const double eps=1e-8;#define ll long longusing namespace std;const int inf=1e9;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int p[MAXN],q,n,key,rt,base;bool Num[NM],vis[MAXN],ans[MAXN];int sz[MAXN],maxx[MAXN];void get_root(int x,int pre)&#123; sz[x]=1;maxx[x]=0; link(x)&#123; if(j-&gt;t==pre||vis[j-&gt;t])continue; get_root(j-&gt;t,x); sz[x]+=sz[j-&gt;t];maxx[x]=max(maxx[x],sz[j-&gt;t]); &#125; maxx[x]=max(maxx[x],base-sz[x]); if(key&gt;maxx[x])rt=x,key=maxx[x];&#125;int st[MAXN],St[MAXN],tot,tot1;int dis[MAXN];void dfs(int x,int pre)&#123; if(dis[x]&lt;NM)st[++tot]=dis[x],St[++tot1]=dis[x]; link(x)&#123; if(j-&gt;t==pre||vis[j-&gt;t])continue; dis[j-&gt;t]=dis[x]+j-&gt;v; dfs(j-&gt;t,x); &#125;&#125;void solve(int x)&#123; tot1=0;Num[0]=1;vis[x]=1; link(x)&#123; if(vis[j-&gt;t])continue; tot=0;dis[j-&gt;t]=j-&gt;v;dfs(j-&gt;t,x); inc(i,1,tot)inc(k,1,q)if(st[i]&lt;=p[k]&amp;&amp;Num[p[k]-st[i]])ans[k]=1; inc(i,1,tot)Num[st[i]]=1; &#125; inc(i,1,tot1)Num[St[i]]=0;Num[0]=0; link(x)&#123; if(vis[j-&gt;t])continue; key=inf;base=sz[j-&gt;t];get_root(j-&gt;t,0); solve(rt); &#125;&#125;int main()&#123; inc(i,0,NM-1)Num[i]=0; n=read();q=read(); int x,y,z; inc(i,2,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); inc(i,1,q)p[i]=read(); key=inf;base=n;get_root(1,0); solve(rt); inc(i,1,q)if(!p[i]||ans[i])puts("Yes");else puts("No"); return 0;&#125; 题目描述一棵$n$个点的带权有根树，有$p$个询问，每次询问树中是否存在一条长度为$Len$的路径，如果是，输出$Yes$否输出$No$. Input第一行两个整数$n, p$分别表示点的个数和询问的个数． 接下来$n-1$行每行三个数$x, y, c$，表示有一条树边$x→y$，长度为$c$． 接下来$p$行每行一个数$Len$，表示询问树中是否存在一条长度为$Len$的路径． Output输出有$p$行，$Yes$或$No$.]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj2599(点分治)]]></title>
    <url>%2F2019%2F03%2F11%2Fbzoj2599-%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[题解讲个鬼故事~~ 第一次xjb写了一个点分治 统计贡献甚至没有去掉同颗子树的情况 骗了75分……..然后对拍写挂了 生成数据从1到n 对拍找不到错 …真是太菜了 言归正传: 对于统计贡献 我们可以把重心的儿子的子树一个个合并 然后维护答案就行了 坑点就是….别把$K$当做$N$ 然后注意别用$memset$来清空 直接用数组记录修改的位置 然后$for$循环清空就行了 注意还有不存在的情况需要处理 复杂度 $O(nlogn)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const int NM=1e6+10;const double eps=1e-8;#define ll long longconst int inf=1e9+7;using namespace std;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int n,K;bool vis[MAXN];ll dis[MAXN];int cnt[MAXN];int base,key,rt;int sz[MAXN],maxx[MAXN];void get_root(int x,int pre)&#123; sz[x]=1;maxx[x]=0; link(x)&#123; if(j-&gt;t==pre||vis[j-&gt;t])continue; get_root(j-&gt;t,x); sz[x]+=sz[j-&gt;t];maxx[x]=max(maxx[x],sz[j-&gt;t]); &#125; maxx[x]=max(maxx[x],base-sz[x]); if(key&gt;maxx[x])key=maxx[x],rt=x;&#125;int st[MAXN],tot,ans,St[MAXN],tot1;int num[NM],Num[NM];void dfs(int x,int pre)&#123; if(dis[x]&lt;=K)st[++tot]=dis[x],num[dis[x]]=min(num[dis[x]],cnt[x]),St[++tot1]=dis[x]; link(x)&#123; if(j-&gt;t==pre||vis[j-&gt;t])continue; dis[j-&gt;t]=dis[x]+j-&gt;v;cnt[j-&gt;t]=cnt[x]+1; dfs(j-&gt;t,x); &#125;&#125;void solve(int x)&#123; vis[x]=1;tot1=0;Num[0]=0; link(x)&#123; if(vis[j-&gt;t])continue; tot=0;dis[j-&gt;t]=j-&gt;v;cnt[j-&gt;t]=1;dfs(j-&gt;t,x); inc(i,1,tot)ans=min(ans,num[st[i]]+Num[K-st[i]]); inc(i,1,tot)Num[st[i]]=min(Num[st[i]],num[st[i]]),num[st[i]]=inf; &#125; inc(i,1,tot1)Num[St[i]]=inf; Num[0]=inf; link(x)&#123; if(vis[j-&gt;t])continue; key=inf;base=sz[j-&gt;t];get_root(j-&gt;t,0); solve(rt); &#125;&#125;int main()&#123; n=read();K=read(); int x,y,z; inc(i,1,K)num[i]=Num[i]=inf; inc(i,2,n)x=read()+1,y=read()+1,z=read(),add(x,y,z),add(y,x,z); ans=inf;key=inf;base=n;get_root(1,0); solve(rt); if(ans==inf)printf("-1\n"); else printf("%d\n",ans);&#125; 题目描述给一棵树,每条边有权.求一条简单路径,权值和等于$K$,且边的数量最小.$N &lt;= 200000$,$ K &lt;= 1000000$ Input第一行 两个整数 $n, k$第$二…….N$行 每行三个整数 表示一条无向边的两端和权值 (注意点的编号从0开始) Output一个整数 表示最小边数量 如果不存在这样的路径 输出$-1​$]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj2152(点分治)]]></title>
    <url>%2F2019%2F03%2F11%2Fbzoj2152-%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[题解点分治模板题 不同的是 我们不需要sort 也不需要去重 对于每个子树重心做一个树$dp$即可 $dp[x][y]$表示x的子树中到x距离模3后y的个数 然后对于每个子树重心 合并维护答案即可 $复杂度O(nlogn)$ 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;#define ll long longusing namespace std;const int inf=1e9;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int n;int base,key,pos,sz[MAXN],maxx[MAXN],rt;bool vis[MAXN];void get_root(int x,int pre)&#123; sz[x]=1;maxx[x]=0; link(x)&#123; if(vis[j-&gt;t]||j-&gt;t==pre)continue; get_root(j-&gt;t,x); sz[x]+=sz[j-&gt;t];maxx[x]=max(maxx[x],sz[j-&gt;t]); &#125; maxx[x]=max(maxx[x],base-sz[x]); if(key&gt;maxx[x])key=maxx[x],rt=x;&#125;int t[MAXN][4];ll dis[MAXN];void dfs(int x,int pre)&#123; t[x][0]=t[x][1]=t[x][2]=0; t[x][dis[x]%3]++; link(x)&#123; if(vis[j-&gt;t]||j-&gt;t==pre)continue; dis[j-&gt;t]=dis[x]+j-&gt;v; dfs(j-&gt;t,x); t[x][0]+=t[j-&gt;t][0];t[x][1]+=t[j-&gt;t][1];t[x][2]+=t[j-&gt;t][2]; &#125;&#125;ll ans;void solve(int x,int pre)&#123; vis[x]=1;dis[x]=0; dfs(x,0); t[x][0]=t[x][1]=t[x][2]=0;t[x][0]++; link(x)&#123; if(vis[j-&gt;t]||j-&gt;t==pre)continue; ans+=1ll*t[x][0]*t[j-&gt;t][0]; ans+=1ll*t[x][1]*t[j-&gt;t][2]; ans+=1ll*t[x][2]*t[j-&gt;t][1]; t[x][0]+=t[j-&gt;t][0];t[x][1]+=t[j-&gt;t][1];t[x][2]+=t[j-&gt;t][2]; &#125; link(x)&#123; if(vis[j-&gt;t]||j-&gt;t==pre)continue; key=inf;base=sz[j-&gt;t];get_root(j-&gt;t,x); solve(rt,0); &#125;&#125;int main()&#123; n=read(); int x,y,z; inc(i,2,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); ans=0; base=n;key=inf;get_root(1,0); solve(rt,0); ll t1=2*ans+n;ll t2=1ll*n*n; ll t=__gcd(t1,t2);t1/=t;t2/=t; printf("%lld/%lld\n",t1,t2); return 0;&#125; 题目描述聪聪和可可是兄弟俩，他们俩经常为了一些琐事打起来，例如家中只剩下最后一根冰棍而两人都想吃、两个人都想玩儿电脑（可是他们家只有一台电脑）……遇到这种问题，一般情况下石头剪刀布就好了，可是他们已经玩儿腻了这种低智商的游戏。他们的爸爸快被他们的争吵烦死了，所以他发明了一个新游戏：由爸爸在纸上画$n$个“点”，并用$n-1$条“边”把这$n$个“点”恰好连通（其实这就是一棵树）。并且每条“边”上都有一个数。接下来由聪聪和可可分别随即选一个点（当然他们选点时是看不到这棵树的），如果两个点之间所有边上数的和加起来恰好是$3$的倍数，则判聪聪赢，否则可可赢。聪聪非常爱思考问题，在每次游戏后都会仔细研究这棵树，希望知道对于这张图自己的获胜概率是多少。现请你帮忙求出这个值以验证聪聪的答案是否正确。 Input输入的第1行包含1个正整数$n$。后面$n-1$行，每行$3$个整数$x、y、w$，表示$x$号点和$y$号点之间有一条边，上面的数是$w$。 Output以即约分数形式输出这个概率（即$“a/b”$的形式，其中$a$和$b$必须互质。如果概率为$1$，输出$“1/1”$）。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj3365(点分治)]]></title>
    <url>%2F2019%2F03%2F11%2Fbzoj3365-%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[题解同上题 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;#define ll long longusing namespace std;const int inf=1e9;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int n,K;int rt,base,sz[MAXN],maxx[MAXN],key;bool vis[MAXN];ll ans;void get_root(int x,int pre)&#123; sz[x]=1;maxx[x]=0; link(x)&#123; if(j-&gt;t==pre||vis[j-&gt;t])continue; get_root(j-&gt;t,x); sz[x]+=sz[j-&gt;t];maxx[x]=max(maxx[x],sz[j-&gt;t]); &#125; maxx[x]=max(maxx[x],base-sz[x]); if(maxx[x]&lt;key)key=maxx[x],rt=x;&#125;ll st[MAXN],dis[MAXN];int tot,num[MAXN];void get_deep(int x,int pre)&#123; num[x]=1; if(!pre)st[++tot]=dis[x]; link(x)&#123; if(j-&gt;t==pre||vis[j-&gt;t])continue; dis[j-&gt;t]=dis[x]+j-&gt;v;st[++tot]=dis[j-&gt;t]; get_deep(j-&gt;t,x); num[x]+=num[j-&gt;t]; &#125;&#125;ll get_sum(int x,ll dist)&#123; dis[x]=dist;tot=0;get_deep(x,0); sort(st+1,st+tot+1); ll sum=0; inc(i,1,tot)&#123; int l=i+1;int r=tot;int ans1=0; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(st[i]+st[mid]&lt;=K)ans1=mid,l=mid+1; else r=mid-1; &#125; if(!ans1)continue; sum+=ans1-i; &#125; return sum;&#125;void solve(int x,int y)&#123; vis[x]=1;ans+=get_sum(x,0); link(x)&#123; if(j-&gt;t==y||vis[j-&gt;t])continue; key=inf;base=num[j-&gt;t];get_root(j-&gt;t,x);ans-=get_sum(j-&gt;t,j-&gt;v); solve(rt,x); &#125;&#125;int main()&#123; int x,y,z; char ch; n=read();int m=read(); inc(i,2,n)scanf("%d %d %d %c",&amp;x,&amp;y,&amp;z,&amp;ch),add(x,y,z),add(y,x,z); K=read(); key=inf;base=n;get_root(1,0); solve(rt,0); printf("%lld\n",ans);&#125; 题目描述https://www.lydsy.com/JudgeOnline/problem.php?id=3365]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1468(点分治)]]></title>
    <url>%2F2019%2F03%2F11%2Fbzoj1468-%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[题解点分治模板题 第一次写点分治 那就把我的心酸证明历程也记录下吧 首先:前置知识点 树的重心(当$x$为根时,其子树节点的$size$的最大值最小) 然后每次以子树重心分治 保证分治层数不超过$logn$层 证明: 我们假如其$size_u&gt;size/2$那么 我们必然可以往其$size$较大的子树节点继续选择 那么这个点就不在是重心 然后:考虑如何统计点对贡献 我们可以处理出当前子树节点到$rt$的距离 然后$sort$以后双指针/二分查询贡献 但是这样会把子树节点内的点对重复计数 所以每次需要去重一下 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;#define ll long longusing namespace std;const int inf=1e9;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int n,K;int rt,base,sz[MAXN],maxx[MAXN],key;bool vis[MAXN];ll ans;void get_root(int x,int pre)&#123; sz[x]=1;maxx[x]=0; link(x)&#123; if(j-&gt;t==pre||vis[j-&gt;t])continue; get_root(j-&gt;t,x); sz[x]+=sz[j-&gt;t];maxx[x]=max(maxx[x],sz[j-&gt;t]); &#125; maxx[x]=max(maxx[x],base-sz[x]); if(maxx[x]&lt;key)key=maxx[x],rt=x;&#125;ll st[MAXN],dis[MAXN];int tot,num[MAXN];void get_deep(int x,int pre)&#123; num[x]=1; if(!pre)st[++tot]=dis[x]; link(x)&#123; if(j-&gt;t==pre||vis[j-&gt;t])continue; dis[j-&gt;t]=dis[x]+j-&gt;v;st[++tot]=dis[j-&gt;t]; get_deep(j-&gt;t,x); num[x]+=num[j-&gt;t]; &#125;&#125;ll get_sum(int x,ll dist)&#123; dis[x]=dist;tot=0;get_deep(x,0); sort(st+1,st+tot+1); ll sum=0; inc(i,1,tot)&#123; int l=i+1;int r=tot;int ans1=0; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(st[i]+st[mid]&lt;=K)ans1=mid,l=mid+1; else r=mid-1; &#125; if(!ans1)continue; sum+=ans1-i; &#125; return sum;&#125;void solve(int x,int y)&#123; vis[x]=1;ans+=get_sum(x,0); link(x)&#123; if(j-&gt;t==y||vis[j-&gt;t])continue; key=inf;base=num[j-&gt;t];get_root(j-&gt;t,x);ans-=get_sum(j-&gt;t,j-&gt;v); solve(rt,x); &#125;&#125;int main()&#123; int x,y,z; n=read(); inc(i,2,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); K=read(); key=inf;base=n;get_root(1,0); solve(rt,0); printf("%lld\n",ans);&#125; 题目描述给你一棵$TREE$,以及这棵树上边的距离.问有多少对点它们两者间的距离小于等于$K$ Input$N(n&lt;=40000)$接下来$n-1$行边描述管道，按照题目中写的输入 接下来是$k$ Output一行，有多少对点之间的距离小于等于$k$]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj2282树形dp]]></title>
    <url>%2F2019%2F03%2F10%2Fbzoj2282-%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[题解首先路径的选择应该是直径的某一段区间…证明略(虽然我也是直观感受的) 然后我们考虑对直径上区间的选择 对于区间[l,r]的价值为$max(dis(直径左端点,l),max(dis(直径右端点,r),子区间上的价值))$ 当$l$保持不变,$r$增加时,区间价值单调不增加,所以我们应该对于每个左端点$l$,找到最大r满足条件 然后统计 然后对于子区间价值的维护 我们可以找到每个点到离其最近直径上点距离的最大值更新并维护直径上点的价值 然后因为我单调队列 写挂了 就直接用线段树查询区间最大值即可 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;#define ll long longusing namespace std;const int inf=1e9+10;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125; int n;int st[MAXN],tot,p[MAXN],dis[MAXN],s;bool vis[MAXN];queue&lt;int&gt;que;int bfs(int x)&#123; inc(i,1,n)dis[i]=vis[i]=0; vis[x]=1;que.push(x); while(!que.empty())&#123; int y=que.front();que.pop(); link(y)if(!vis[j-&gt;t])vis[j-&gt;t]=1,dis[j-&gt;t]=dis[y]+j-&gt;v,que.push(j-&gt;t); &#125; int pos=x; inc(i,1,n)if(dis[pos]&lt;dis[i])pos=i; return pos;&#125; int sum[MAXN],fa[MAXN],ans[MAXN],key[MAXN];void dfs(int x,int pre)&#123; fa[x]=pre; link(x)if(j-&gt;t!=pre)sum[j-&gt;t]=sum[x]+j-&gt;v,key[j-&gt;t]=j-&gt;v,dfs(j-&gt;t,x);&#125; void _dfs(int x,int y)&#123; int k; if(vis[x])k=x;else k=y; p[x]=k; link(x)if(j-&gt;t!=fa[x])_dfs(j-&gt;t,k);&#125; int maxx[MAXN&lt;&lt;2],R[MAXN];void built(int x,int l,int r)&#123; if(l==r)&#123;maxx[x]=ans[st[l]];return ;&#125; int mid=(l+r)&gt;&gt;1; built(x&lt;&lt;1,l,mid); built(x&lt;&lt;1|1,mid+1,r); maxx[x]=max(maxx[x&lt;&lt;1],maxx[x&lt;&lt;1|1]);&#125; int Maxx;void query(int x,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;Maxx=max(Maxx,maxx[x]);return ;&#125; int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid)query(x&lt;&lt;1,l,mid,ql,qr); if(qr&gt;mid)query(x&lt;&lt;1|1,mid+1,r,ql,qr);&#125; int main()&#123; n=read();s=read(); int x,y,z; inc(i,2,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); x=bfs(1);y=bfs(x); dfs(x,0);tot=0; inc(i,1,n)vis[i]=0; int k1=y; while(y)st[++tot]=y,vis[y]=1,y=fa[y]; y=k1; _dfs(x,x); inc(i,1,n)ans[p[i]]=max(ans[p[i]],sum[i]-sum[p[i]]); built(1,1,tot); inc(i,1,tot)R[i]=R[i-1]+key[st[i]]; int ans2=inf; // cout&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;endl; inc(i,1,tot)&#123; int l=i;int r=tot;int ans1=0; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(R[mid]-R[i-1]&lt;=s)ans1=mid,l=mid+1; else r=mid-1; &#125; if(!ans1)ans1=i;else ans1=min(tot,ans1+1);// cout&lt;&lt;i&lt;&lt;"::: "&lt;&lt;ans1&lt;&lt;endl; Maxx=0;query(1,1,tot,i,ans1); ans2=min(ans2,max(Maxx,max(sum[y]-sum[st[i]],sum[st[ans1]]-sum[x]))); &#125; printf("%d\n",ans2); return 0; &#125; 题目描述某个国家有$n$个城市，这$n$个城市中任意两个都连通且有唯一一条路径，每条连通两个城市的道路的长度为$z_i(z_i&lt;=1000)$。 这个国家的人对火焰有超越宇宙的热情，所以这个国家最兴旺的行业是消防业。由于政府对国民的热情忍无可忍（大量的消防经费开销）可是却又无可奈何（总统竞选的国民支持率），所以只能想尽方法提高消防能力。 现在这个国家的经费足以在一条边长度和不超过$s$的路径（两端都是城市）上建立消防枢纽，为了尽量提高枢纽的利用率，要求其他所有城市到这条路径的距离的最大值最小。 你受命监管这个项目，你当然需要知道应该把枢纽建立在什么位置上。 Input输入包含$n$行：第$1$行，两个正整数$n$和$s$，中间用一个空格隔开。其中$n$为城市的个数,$s$为路径长度的上界。设结点编号以此为$1，2，……，n$。从第$2$行到第$n$行，每行给出$3$个用空格隔开的正整数，依次表示每一条边的两个端点编号和长度。例如，$“2 4 7”$表示连接结点$2$与$4$的边的长度为$7$。 Output输出包含一个非负整数，即所有城市到选择的路径的最大值，当然这个最大值必须是所有方案中最小的。]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1509(树形dp)]]></title>
    <url>%2F2019%2F03%2F10%2Fbzoj1509-%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[题解从一棵树里面找三个点$x,y,z$,从点$x$出发,先到另外两个点中离$x$较近的点,然后再到剩下那个点的路径和最大.首先对于直径两端点是必然选择,然后枚举起点,统计答案即可 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,long long&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;#define ll long longusing namespace std;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int n,m;ll dis[MAXN];bool vis[MAXN];queue&lt;int&gt;que;pii bfs(int x)&#123; inc(i,1,n)dis[i]=vis[i]=0; que.push(x);vis[x]=1; while(!que.empty())&#123; int y=que.front();que.pop(); link(y)&#123; if(!vis[j-&gt;t])vis[j-&gt;t]=1,dis[j-&gt;t]=dis[y]+j-&gt;v,que.push(j-&gt;t); &#125; &#125; pii pos=mp(x,0); inc(i,1,n)if(dis[pos.first]&lt;dis[i])pos=mp(i,dis[i]); return pos;&#125;int fa[MAXN];void dfs(int x,int pre)&#123; fa[x]=pre; link(x)if(j-&gt;t!=pre)dfs(j-&gt;t,x);&#125;int p[MAXN];ll sum[MAXN];void _dfs(int x,int y)&#123; int k; if(vis[x])k=x;else k=y; p[x]=k; link(x)if(j-&gt;t!=fa[x])sum[j-&gt;t]=sum[x]+j-&gt;v,_dfs(j-&gt;t,k);&#125;int main()&#123; n=read();m=read(); int x,y,z; inc(i,2,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); pii t1=bfs(1); pii t2=bfs(t1.first); ll ans=t2.second; dfs(t1.first,0);x=t2.first; inc(i,1,n)vis[i]=0; while(x)&#123;vis[x]=1;x=fa[x];&#125; _dfs(t1.first,t1.first); ll maxx=0; inc(i,1,n)maxx=max(maxx,sum[i]-sum[p[i]]+min(sum[p[i]]-sum[t1.first],sum[t2.first]-sum[p[i]])); printf("%lld\n",maxx+ans);&#125; 题目描述https://www.lydsy.com/JudgeOnline/problem.php?id=1509 Input第一行是两个整数$N(3&lt;=N&lt;=200000),M$,分别表示居住点总数和街道总数,以下$M$行，每行给出一条街道的信息。第$i+1$行包含整数$Ui、Vi、Ti（1&lt;=U_i, V_i &lt;= N，1 &lt;= T_i&lt;=1000000000)$，表示街道$i$连接居住点$U_i$和$V_i$，并且经过街道$i$需花费$T_i$分钟。街道信息不会重复给出。 Output仅包含整数$T$，即最坏情况下Chris的父母需要花费$T$分钟才能找到Chris。]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1912(树形dp)]]></title>
    <url>%2F2019%2F03%2F10%2Fbzoj1912-%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[题解 $ k=1 $ 必然连接直径两端 我们考虑$ k=2 $的情况 首先明确选的两条路径 选直径是否还是最优的?当然,不管如何考虑选直径带来的优势要大于不选直径 然后对于第二条路的选择 如果第二条路和直径有交边 那么交边还是会经过两次 那么就是让 两条路径并起来的部分减去交的部分长度最长 我们可以考虑将选出来的直径的边权置$-1$ 然后再求一遍树的直径 这样子就必然能得到最优解 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;#define ll long longusing namespace std;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int t)&#123;o-&gt;t=y;o-&gt;v=t;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125; int n,k;bool vis[MAXN];int dis[MAXN];queue&lt;int&gt;que;pii bfs(int x)&#123; inc(i,1,n)vis[i]=dis[i]=0; que.push(x);vis[x]=1; while(!que.empty())&#123; int y=que.front();que.pop(); link(y)&#123; if(!vis[j-&gt;t])vis[j-&gt;t]=1,dis[j-&gt;t]=dis[y]+j-&gt;v,que.push(j-&gt;t); &#125; &#125; pii pos=mp(x,0); inc(i,1,n)if(dis[pos.first]&lt;dis[i])pos=mp(i,dis[i]); return pos;&#125; int fa[MAXN]; void dfs(int x,int pre)&#123; fa[x]=pre; link(x)&#123; if(j-&gt;t==pre)continue; dfs(j-&gt;t,x); &#125;&#125; void _dfs(int x,int pre)&#123; link(x)&#123; if(j-&gt;t==pre)&#123;continue;&#125; if(vis[j-&gt;t])j-&gt;v=-1,_dfs(j-&gt;t,x); &#125;&#125; int dp[MAXN],dp1[MAXN];int st[MAXN],tot;bool cmp(int x,int y)&#123;return x&gt;y;&#125; void __dfs(int x,int pre)&#123; link(x)&#123; if(j-&gt;t==pre)continue; __dfs(j-&gt;t,x); dp[x]=max(dp[x],dp[j-&gt;t]); &#125; tot=0; link(x)&#123; if(j-&gt;t==pre)continue; st[++tot]=dp1[j-&gt;t]+j-&gt;v; &#125; sort(st+1,st+tot+1,cmp); // cout&lt;&lt;x&lt;&lt;"::: "&lt;&lt;tot&lt;&lt;" "&lt;&lt;st[1]&lt;&lt;endl; if(tot==0)return ; else if(tot==1)dp[x]=max(dp[x],st[1]),dp1[x]=st[1]; else dp[x]=max(dp[x],max(st[1]+st[2],st[1])),dp1[x]=st[1]; // cout&lt;&lt;x&lt;&lt;"::: "&lt;&lt;dp[x]&lt;&lt;endl;&#125; int main()&#123; n=read();k=read(); int x,y; inc(i,2,n)x=read(),y=read(),add(x,y,1),add(y,x,1); int ans=2*(n-1); pii t1,t2; t1=bfs(1);t2=bfs(t1.first); ans-=t2.second-1; if(k==2)&#123; inc(i,1,n)vis[i]=0; x=t2.first;y=t1.first; dfs(y,0); while(x)&#123; vis[x]=1; x=fa[x]; &#125; _dfs(y,0);__dfs(y,0); ans-=dp[y]-1; &#125; printf("%d\n",ans); return 0;&#125; 题目描述https://www.lydsy.com/JudgeOnline/problem.php?id=1912 Input第一行包含两个整数$n$,$K(1 ≤ K ≤ 2)$.接下来$n – 1$行，每行两个整数 $a, b$,表示村庄$a$与$b$之间有一条道路$(1 ≤ a, b ≤ n)$。 Output输出一个整数，表示新建了$K$条道路后能达到的最小巡逻距离。]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj4987(树形dp)]]></title>
    <url>%2F2019%2F03%2F09%2Fbzoj4987-%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[题解首先,$\sum_{i=1}^{k-1} dis(a_i,a_{i+1})​$ 最小化 那么对于这$k​$个点的选择可见必然是一个连通子树 可以反证 如何统计价值呢?我们考虑对于一棵树如何遍历每个点让路径和最小 显然是 $ 2sum-len​$ 即2倍路径和减去直径 这样子我们可以设$dp[i][j][0/1/2]​$ 表示在$i​$的子树中选了$j​$个点的联通子树 且直径的三种形态下的最小值 转移留给读者思考 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e3+10;const double eps=1e-8;#define ll long longconst ll inf=2e9;using namespace std;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int n,m,sz[MAXN];ll dp[MAXN][MAXN][3];ll ans;int check(int x,int y)&#123; if(x==1&amp;&amp;y==1)return 1; else if(x==0&amp;&amp;y==1)return 1; return 2;&#125;void dfs(int x,int pre)&#123; sz[x]=1; link(x)&#123; if(j-&gt;t==pre)continue; dfs(j-&gt;t,x); dec(i,min(sz[x],m),1)inc(k,0,2)for(int r=1;r+i&lt;=m&amp;&amp;r&lt;=sz[j-&gt;t];r++)inc(p,0,2-k)&#123; dp[x][i+r][k+p]=min(dp[x][i+r][k+p],dp[j-&gt;t][r][p]+dp[x][i][k]+(j-&gt;v)*check(k,p)); &#125; sz[x]+=sz[j-&gt;t]; &#125; ans=min(ans,min(dp[x][m][1],dp[x][m][2]));&#125;int main()&#123; n=read();m=read(); int x,y,z; inc(i,2,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); inc(i,1,n)inc(j,0,m)dp[i][j][0]=dp[i][j][1]=dp[i][j][2]=inf; inc(i,1,n)dp[i][1][1]=dp[i][1][0]=0; ans=inf; dfs(1,0); printf("%lld\n",ans);&#125; 题目描述从前有棵树。找出$K$个点$A_1,A_2,…,A_k$。最小化$\sum_{i=1}^{k-1} dis(a_i,a_{i+1})$ 输入描述第一行两个正整数$n$,$k$,表示数的顶点数和需要选出的点个数。 接下来$n-1$行每行3个非负整数$x$,$y$,$z$，表示从存在一条从$x$到$y$权值为$z$的边 输出描述一行一个整数，表示最小的距离和。]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj3124(树形dp)]]></title>
    <url>%2F2019%2F03%2F09%2Fbzoj3124-%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[题解:我们考虑找出任意一条直径的两个端点$x$,$y$ 对直径上的节点打上标记 对于其他不在直径上的点$v$ 找到其离的最近的标记点$pos$ 我们考虑当前$dis[pos]-dis[x]$与$dis[y]-dis[pos]$的大小关系然后判断$v$是否为分叉直径上的节点 若是则对原标记节点打上标记 最后的答案则为 每条边的权值是否等于分叉直径的条数 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;#define ll long longusing namespace std;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125; ll dis[MAXN];int n;bool vis[MAXN];queue&lt;int&gt;que;int bfs(int x)&#123; inc(i,1,n)vis[i]=dis[i]=0; que.push(x);vis[x]=1; while(!que.empty())&#123; int y=que.front();que.pop(); link(y)&#123; if(!vis[j-&gt;t])dis[j-&gt;t]=dis[y]+j-&gt;v,vis[j-&gt;t]=1,que.push(j-&gt;t); &#125; &#125; int pos=x; inc(i,1,n)&#123; if(dis[i]&gt;dis[pos])pos=i; &#125; return pos;&#125; int fa[MAXN],p[MAXN];ll sum[MAXN]; void dfs(int x,int pre)&#123; fa[x]=pre; link(x)&#123; if(j-&gt;t==pre)continue; sum[j-&gt;t]=sum[x]+j-&gt;v; dfs(j-&gt;t,x); &#125;&#125; void work(int y)&#123; inc(i,1,n)vis[i]=0; while(y)&#123; vis[y]=1;y=fa[y]; &#125;&#125; void _dfs(int x,int y)&#123; int k; if(vis[x])k=x;else k=y; p[x]=k; link(x)&#123; if(j-&gt;t==fa[x])continue; _dfs(j-&gt;t,k); &#125;&#125; int ans[MAXN]; void __dfs(int x)&#123; link(x)&#123; if(j-&gt;t==fa[x])continue; __dfs(j-&gt;t); ans[x]+=ans[j-&gt;t]; &#125;&#125; int main()&#123; n=read(); int x,y,z; inc(i,2,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); x=bfs(1);y=bfs(x); dfs(x,0);work(y);_dfs(x,x); ll len=sum[y]-sum[x]; printf("%lld\n",sum[y]-sum[x]); int cnt=0; inc(i,1,n)&#123; if(vis[i])continue; ll t1=sum[i]-sum[p[i]]; if(sum[p[i]]-sum[x]&gt;sum[y]-sum[p[i]])&#123; if(sum[p[i]]-sum[x]+t1==len)ans[p[i]]++,cnt++; &#125; else if(sum[p[i]]-sum[x]&lt;sum[y]-sum[p[i]])&#123; if(sum[y]-sum[p[i]]+t1==len)ans[y]++,ans[p[i]]--,cnt++; &#125; else&#123; if(t1==sum[p[i]]-sum[x])cnt++; &#125; &#125; __dfs(x); int ans1=0; inc(i,1,n)&#123; if(i==x||!vis[i])continue; if(ans[i]==cnt)ans1++; &#125; printf("%d\n",ans1);&#125; 题目描述小Q最近学习了一些图论知识。根据课本，有如下定义。树：无回路且连通的无向图，每条边都有正整数的权值来表示其长度。如果一棵树有$N$个节点，可以证明其有且仅有$N-1$条边。 路径：一棵树上，任意两个节点之间最多有一条简单路径。我们用$dis(a,b)$表示点$a$和点$b$的路径上各边长度之和。称$dis(a,b)$为$a$ ,$b$两个节点间的距离。直径：一棵树上，最长的路径为树的直径。树的直径可能不是唯一的。现在小Q想知道，对于给定的一棵树，其直径的长度是多少，以及有多少条边满足所有的直径都经过该边。 输入描述第一行包含一个整数$N$，表示节点数。接下来$N-1$行，每行三个整数$a$,$ b$,$ c$ ,表示点 $a$和点$b$之间有一条长度为$c$的无向边。 输出描述共两行。第一行一个整数，表示直径的长度。第二行一个整数，表示被所有直径经过的边的数量。]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
</search>
