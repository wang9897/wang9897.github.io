<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[bzoj1509(树形dp)]]></title>
    <url>%2F2019%2F03%2F10%2Fbzoj1509-%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[题解从一棵树里面找三个点$x,y,z$,从点$x$出发,先到另外两个点中离$x$较近的点,然后再到剩下那个点的路径和最大.首先对于直径两端点是必然选择,然后枚举起点,统计答案即可 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,long long&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;#define ll long longusing namespace std;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int n,m;ll dis[MAXN];bool vis[MAXN];queue&lt;int&gt;que;pii bfs(int x)&#123; inc(i,1,n)dis[i]=vis[i]=0; que.push(x);vis[x]=1; while(!que.empty())&#123; int y=que.front();que.pop(); link(y)&#123; if(!vis[j-&gt;t])vis[j-&gt;t]=1,dis[j-&gt;t]=dis[y]+j-&gt;v,que.push(j-&gt;t); &#125; &#125; pii pos=mp(x,0); inc(i,1,n)if(dis[pos.first]&lt;dis[i])pos=mp(i,dis[i]); return pos;&#125;int fa[MAXN];void dfs(int x,int pre)&#123; fa[x]=pre; link(x)if(j-&gt;t!=pre)dfs(j-&gt;t,x);&#125;int p[MAXN];ll sum[MAXN];void _dfs(int x,int y)&#123; int k; if(vis[x])k=x;else k=y; p[x]=k; link(x)if(j-&gt;t!=fa[x])sum[j-&gt;t]=sum[x]+j-&gt;v,_dfs(j-&gt;t,k);&#125;int main()&#123; n=read();m=read(); int x,y,z; inc(i,2,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); pii t1=bfs(1); pii t2=bfs(t1.first); ll ans=t2.second; dfs(t1.first,0);x=t2.first; inc(i,1,n)vis[i]=0; while(x)&#123;vis[x]=1;x=fa[x];&#125; _dfs(t1.first,t1.first); ll maxx=0; inc(i,1,n)maxx=max(maxx,sum[i]-sum[p[i]]+min(sum[p[i]]-sum[t1.first],sum[t2.first]-sum[p[i]])); printf("%lld\n",maxx+ans);&#125; 题目描述https://www.lydsy.com/JudgeOnline/problem.php?id=1509 Input第一行是两个整数$N(3&lt;=N&lt;=200000),M$,分别表示居住点总数和街道总数,以下$M$行，每行给出一条街道的信息。第$i+1$行包含整数$Ui、Vi、Ti（1&lt;=U_i, V_i &lt;= N，1 &lt;= T_i&lt;=1000000000)$，表示街道$i$连接居住点$U_i$和$V_i$，并且经过街道$i$需花费$T_i$分钟。街道信息不会重复给出。 Output仅包含整数$T$，即最坏情况下Chris的父母需要花费$T$分钟才能找到Chris。]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1912(树形dp)]]></title>
    <url>%2F2019%2F03%2F10%2Fbzoj1912-%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[题解 $ k=1 $ 必然连接直径两端 我们考虑$ k=2 $的情况 首先明确选的两条路径 选直径是否还是最优的?当然,不管如何考虑选直径带来的优势要大于不选直径 然后对于第二条路的选择 如果第二条路和直径有交边 那么交边还是会经过两次 那么就是让 两条路径并起来的部分减去交的部分长度最长 我们可以考虑将选出来的直径的边权置$-1$ 然后再求一遍树的直径 这样子就必然能得到最优解 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;#define ll long longusing namespace std;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int t)&#123;o-&gt;t=y;o-&gt;v=t;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125; int n,k;bool vis[MAXN];int dis[MAXN];queue&lt;int&gt;que;pii bfs(int x)&#123; inc(i,1,n)vis[i]=dis[i]=0; que.push(x);vis[x]=1; while(!que.empty())&#123; int y=que.front();que.pop(); link(y)&#123; if(!vis[j-&gt;t])vis[j-&gt;t]=1,dis[j-&gt;t]=dis[y]+j-&gt;v,que.push(j-&gt;t); &#125; &#125; pii pos=mp(x,0); inc(i,1,n)if(dis[pos.first]&lt;dis[i])pos=mp(i,dis[i]); return pos;&#125; int fa[MAXN]; void dfs(int x,int pre)&#123; fa[x]=pre; link(x)&#123; if(j-&gt;t==pre)continue; dfs(j-&gt;t,x); &#125;&#125; void _dfs(int x,int pre)&#123; link(x)&#123; if(j-&gt;t==pre)&#123;continue;&#125; if(vis[j-&gt;t])j-&gt;v=-1,_dfs(j-&gt;t,x); &#125;&#125; int dp[MAXN],dp1[MAXN];int st[MAXN],tot;bool cmp(int x,int y)&#123;return x&gt;y;&#125; void __dfs(int x,int pre)&#123; link(x)&#123; if(j-&gt;t==pre)continue; __dfs(j-&gt;t,x); dp[x]=max(dp[x],dp[j-&gt;t]); &#125; tot=0; link(x)&#123; if(j-&gt;t==pre)continue; st[++tot]=dp1[j-&gt;t]+j-&gt;v; &#125; sort(st+1,st+tot+1,cmp); // cout&lt;&lt;x&lt;&lt;"::: "&lt;&lt;tot&lt;&lt;" "&lt;&lt;st[1]&lt;&lt;endl; if(tot==0)return ; else if(tot==1)dp[x]=max(dp[x],st[1]),dp1[x]=st[1]; else dp[x]=max(dp[x],max(st[1]+st[2],st[1])),dp1[x]=st[1]; // cout&lt;&lt;x&lt;&lt;"::: "&lt;&lt;dp[x]&lt;&lt;endl;&#125; int main()&#123; n=read();k=read(); int x,y; inc(i,2,n)x=read(),y=read(),add(x,y,1),add(y,x,1); int ans=2*(n-1); pii t1,t2; t1=bfs(1);t2=bfs(t1.first); ans-=t2.second-1; if(k==2)&#123; inc(i,1,n)vis[i]=0; x=t2.first;y=t1.first; dfs(y,0); while(x)&#123; vis[x]=1; x=fa[x]; &#125; _dfs(y,0);__dfs(y,0); ans-=dp[y]-1; &#125; printf("%d\n",ans); return 0;&#125; 题目描述https://www.lydsy.com/JudgeOnline/problem.php?id=1912 Input第一行包含两个整数$n$,$K(1 ≤ K ≤ 2)$.接下来$n – 1$行，每行两个整数 $a, b$,表示村庄$a$与$b$之间有一条道路$(1 ≤ a, b ≤ n)$。 Output输出一个整数，表示新建了$K$条道路后能达到的最小巡逻距离。]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj4987(树形dp)]]></title>
    <url>%2F2019%2F03%2F09%2Fbzoj4987-%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[题解首先,$\sum_{i=1}^{k-1} dis(a_i,a_{i+1})​$ 最小化 那么对于这$k​$个点的选择可见必然是一个连通子树 可以反证 如何统计价值呢?我们考虑对于一棵树如何遍历每个点让路径和最小 显然是 $ 2sum-len​$ 即2倍路径和减去直径 这样子我们可以设$dp[i][j][0/1/2]​$ 表示在$i​$的子树中选了$j​$个点的联通子树 且直径的三种形态下的最小值 转移留给读者思考 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e3+10;const double eps=1e-8;#define ll long longconst ll inf=2e9;using namespace std;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int n,m,sz[MAXN];ll dp[MAXN][MAXN][3];ll ans;int check(int x,int y)&#123; if(x==1&amp;&amp;y==1)return 1; else if(x==0&amp;&amp;y==1)return 1; return 2;&#125;void dfs(int x,int pre)&#123; sz[x]=1; link(x)&#123; if(j-&gt;t==pre)continue; dfs(j-&gt;t,x); dec(i,min(sz[x],m),1)inc(k,0,2)for(int r=1;r+i&lt;=m&amp;&amp;r&lt;=sz[j-&gt;t];r++)inc(p,0,2-k)&#123; dp[x][i+r][k+p]=min(dp[x][i+r][k+p],dp[j-&gt;t][r][p]+dp[x][i][k]+(j-&gt;v)*check(k,p)); &#125; sz[x]+=sz[j-&gt;t]; &#125; ans=min(ans,min(dp[x][m][1],dp[x][m][2]));&#125;int main()&#123; n=read();m=read(); int x,y,z; inc(i,2,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); inc(i,1,n)inc(j,0,m)dp[i][j][0]=dp[i][j][1]=dp[i][j][2]=inf; inc(i,1,n)dp[i][1][1]=dp[i][1][0]=0; ans=inf; dfs(1,0); printf("%lld\n",ans);&#125; 题目描述从前有棵树。找出$K$个点$A_1,A_2,…,A_k$。最小化$\sum_{i=1}^{k-1} dis(a_i,a_{i+1})$ 输入描述第一行两个正整数$n$,$k$,表示数的顶点数和需要选出的点个数。 接下来$n-1$行每行3个非负整数$x$,$y$,$z$，表示从存在一条从$x$到$y$权值为$z$的边 输出描述一行一个整数，表示最小的距离和。]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj3124(树形dp)]]></title>
    <url>%2F2019%2F03%2F09%2Fbzoj3124-%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[题解:我们考虑找出任意一条直径的两个端点$x$,$y$ 对直径上的节点打上标记 对于其他不在直径上的点$v$ 找到其离的最近的标记点$pos$ 我们考虑当前$dis[pos]-dis[x]$与$dis[y]-dis[pos]$的大小关系然后判断$v$是否为分叉直径上的节点 若是则对原标记节点打上标记 最后的答案则为 每条边的权值是否等于分叉直径的条数 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;#define ll long longusing namespace std;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125; ll dis[MAXN];int n;bool vis[MAXN];queue&lt;int&gt;que;int bfs(int x)&#123; inc(i,1,n)vis[i]=dis[i]=0; que.push(x);vis[x]=1; while(!que.empty())&#123; int y=que.front();que.pop(); link(y)&#123; if(!vis[j-&gt;t])dis[j-&gt;t]=dis[y]+j-&gt;v,vis[j-&gt;t]=1,que.push(j-&gt;t); &#125; &#125; int pos=x; inc(i,1,n)&#123; if(dis[i]&gt;dis[pos])pos=i; &#125; return pos;&#125; int fa[MAXN],p[MAXN];ll sum[MAXN]; void dfs(int x,int pre)&#123; fa[x]=pre; link(x)&#123; if(j-&gt;t==pre)continue; sum[j-&gt;t]=sum[x]+j-&gt;v; dfs(j-&gt;t,x); &#125;&#125; void work(int y)&#123; inc(i,1,n)vis[i]=0; while(y)&#123; vis[y]=1;y=fa[y]; &#125;&#125; void _dfs(int x,int y)&#123; int k; if(vis[x])k=x;else k=y; p[x]=k; link(x)&#123; if(j-&gt;t==fa[x])continue; _dfs(j-&gt;t,k); &#125;&#125; int ans[MAXN]; void __dfs(int x)&#123; link(x)&#123; if(j-&gt;t==fa[x])continue; __dfs(j-&gt;t); ans[x]+=ans[j-&gt;t]; &#125;&#125; int main()&#123; n=read(); int x,y,z; inc(i,2,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); x=bfs(1);y=bfs(x); dfs(x,0);work(y);_dfs(x,x); ll len=sum[y]-sum[x]; printf("%lld\n",sum[y]-sum[x]); int cnt=0; inc(i,1,n)&#123; if(vis[i])continue; ll t1=sum[i]-sum[p[i]]; if(sum[p[i]]-sum[x]&gt;sum[y]-sum[p[i]])&#123; if(sum[p[i]]-sum[x]+t1==len)ans[p[i]]++,cnt++; &#125; else if(sum[p[i]]-sum[x]&lt;sum[y]-sum[p[i]])&#123; if(sum[y]-sum[p[i]]+t1==len)ans[y]++,ans[p[i]]--,cnt++; &#125; else&#123; if(t1==sum[p[i]]-sum[x])cnt++; &#125; &#125; __dfs(x); int ans1=0; inc(i,1,n)&#123; if(i==x||!vis[i])continue; if(ans[i]==cnt)ans1++; &#125; printf("%d\n",ans1);&#125; 题目描述小Q最近学习了一些图论知识。根据课本，有如下定义。树：无回路且连通的无向图，每条边都有正整数的权值来表示其长度。如果一棵树有$N$个节点，可以证明其有且仅有$N-1$条边。 路径：一棵树上，任意两个节点之间最多有一条简单路径。我们用$dis(a,b)$表示点$a$和点$b$的路径上各边长度之和。称$dis(a,b)$为$a$ ,$b$两个节点间的距离。直径：一棵树上，最长的路径为树的直径。树的直径可能不是唯一的。现在小Q想知道，对于给定的一棵树，其直径的长度是多少，以及有多少条边满足所有的直径都经过该边。 输入描述第一行包含一个整数$N$，表示节点数。接下来$N-1$行，每行三个整数$a$,$ b$,$ c$ ,表示点 $a$和点$b$之间有一条长度为$c$的无向边。 输出描述共两行。第一行一个整数，表示直径的长度。第二行一个整数，表示被所有直径经过的边的数量。]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
</search>
