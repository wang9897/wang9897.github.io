<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[bzoj2282树形dp]]></title>
    <url>%2F2019%2F03%2F10%2Fbzoj2282%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[题解首先路径的选择应该是直径的某一段区间…证明略(虽然我也是直观感受的) 然后我们考虑对直径上区间的选择 对于区间[l,r]的价值为$max(dis(直径左端点,l),max(dis(直径右端点,r),子区间上的价值))$ 当$l$保持不变,$r$增加时,区间价值单调不增加,所以我们应该对于每个左端点$l$,找到最大r满足条件 然后统计 然后对于子区间价值的维护 我们可以找到每个点到离其最近直径上点距离的最大值更新并维护直径上点的价值 然后因为我单调队列 写挂了 就直接用线段树查询区间最大值即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;#define ll long longusing namespace std;const int inf=1e9+10;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-&apos;0&apos;,ch=getchar(); return x*f;&#125; int n;int st[MAXN],tot,p[MAXN],dis[MAXN],s;bool vis[MAXN];queue&lt;int&gt;que;int bfs(int x)&#123; inc(i,1,n)dis[i]=vis[i]=0; vis[x]=1;que.push(x); while(!que.empty())&#123; int y=que.front();que.pop(); link(y)if(!vis[j-&gt;t])vis[j-&gt;t]=1,dis[j-&gt;t]=dis[y]+j-&gt;v,que.push(j-&gt;t); &#125; int pos=x; inc(i,1,n)if(dis[pos]&lt;dis[i])pos=i; return pos;&#125; int sum[MAXN],fa[MAXN],ans[MAXN],key[MAXN];void dfs(int x,int pre)&#123; fa[x]=pre; link(x)if(j-&gt;t!=pre)sum[j-&gt;t]=sum[x]+j-&gt;v,key[j-&gt;t]=j-&gt;v,dfs(j-&gt;t,x);&#125; void _dfs(int x,int y)&#123; int k; if(vis[x])k=x;else k=y; p[x]=k; link(x)if(j-&gt;t!=fa[x])_dfs(j-&gt;t,k);&#125; int maxx[MAXN&lt;&lt;2],R[MAXN];void built(int x,int l,int r)&#123; if(l==r)&#123;maxx[x]=ans[st[l]];return ;&#125; int mid=(l+r)&gt;&gt;1; built(x&lt;&lt;1,l,mid); built(x&lt;&lt;1|1,mid+1,r); maxx[x]=max(maxx[x&lt;&lt;1],maxx[x&lt;&lt;1|1]);&#125; int Maxx;void query(int x,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;Maxx=max(Maxx,maxx[x]);return ;&#125; int mid=(l+r)&gt;&gt;1; if(ql&lt;=mid)query(x&lt;&lt;1,l,mid,ql,qr); if(qr&gt;mid)query(x&lt;&lt;1|1,mid+1,r,ql,qr);&#125; int main()&#123; n=read();s=read(); int x,y,z; inc(i,2,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); x=bfs(1);y=bfs(x); dfs(x,0);tot=0; inc(i,1,n)vis[i]=0; int k1=y; while(y)st[++tot]=y,vis[y]=1,y=fa[y]; y=k1; _dfs(x,x); inc(i,1,n)ans[p[i]]=max(ans[p[i]],sum[i]-sum[p[i]]); built(1,1,tot); inc(i,1,tot)R[i]=R[i-1]+key[st[i]]; int ans2=inf; // cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl; inc(i,1,tot)&#123; int l=i;int r=tot;int ans1=0; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(R[mid]-R[i-1]&lt;=s)ans1=mid,l=mid+1; else r=mid-1; &#125; if(!ans1)ans1=i;else ans1=min(tot,ans1+1);// cout&lt;&lt;i&lt;&lt;&quot;::: &quot;&lt;&lt;ans1&lt;&lt;endl; Maxx=0;query(1,1,tot,i,ans1); ans2=min(ans2,max(Maxx,max(sum[y]-sum[st[i]],sum[st[ans1]]-sum[x]))); &#125; printf(&quot;%d\n&quot;,ans2); return 0; &#125; 题目描述某个国家有$n$个城市，这$n$个城市中任意两个都连通且有唯一一条路径，每条连通两个城市的道路的长度为$z_i(z_i&lt;=1000)$。 这个国家的人对火焰有超越宇宙的热情，所以这个国家最兴旺的行业是消防业。由于政府对国民的热情忍无可忍（大量的消防经费开销）可是却又无可奈何（总统竞选的国民支持率），所以只能想尽方法提高消防能力。 现在这个国家的经费足以在一条边长度和不超过$s$的路径（两端都是城市）上建立消防枢纽，为了尽量提高枢纽的利用率，要求其他所有城市到这条路径的距离的最大值最小。 你受命监管这个项目，你当然需要知道应该把枢纽建立在什么位置上。 Input输入包含$n$行：第$1$行，两个正整数$n$和$s$，中间用一个空格隔开。其中$n$为城市的个数,$s$为路径长度的上界。设结点编号以此为$1，2，……，n$。从第$2$行到第$n$行，每行给出$3$个用空格隔开的正整数，依次表示每一条边的两个端点编号和长度。例如，$“2 4 7”$表示连接结点$2$与$4$的边的长度为$7$。 Output输出包含一个非负整数，即所有城市到选择的路径的最大值，当然这个最大值必须是所有方案中最小的。]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1509(树形dp)]]></title>
    <url>%2F2019%2F03%2F10%2Fbzoj1509-%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[题解从一棵树里面找三个点$x,y,z$,从点$x$出发,先到另外两个点中离$x$较近的点,然后再到剩下那个点的路径和最大.首先对于直径两端点是必然选择,然后枚举起点,统计答案即可 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,long long&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;#define ll long longusing namespace std;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int n,m;ll dis[MAXN];bool vis[MAXN];queue&lt;int&gt;que;pii bfs(int x)&#123; inc(i,1,n)dis[i]=vis[i]=0; que.push(x);vis[x]=1; while(!que.empty())&#123; int y=que.front();que.pop(); link(y)&#123; if(!vis[j-&gt;t])vis[j-&gt;t]=1,dis[j-&gt;t]=dis[y]+j-&gt;v,que.push(j-&gt;t); &#125; &#125; pii pos=mp(x,0); inc(i,1,n)if(dis[pos.first]&lt;dis[i])pos=mp(i,dis[i]); return pos;&#125;int fa[MAXN];void dfs(int x,int pre)&#123; fa[x]=pre; link(x)if(j-&gt;t!=pre)dfs(j-&gt;t,x);&#125;int p[MAXN];ll sum[MAXN];void _dfs(int x,int y)&#123; int k; if(vis[x])k=x;else k=y; p[x]=k; link(x)if(j-&gt;t!=fa[x])sum[j-&gt;t]=sum[x]+j-&gt;v,_dfs(j-&gt;t,k);&#125;int main()&#123; n=read();m=read(); int x,y,z; inc(i,2,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); pii t1=bfs(1); pii t2=bfs(t1.first); ll ans=t2.second; dfs(t1.first,0);x=t2.first; inc(i,1,n)vis[i]=0; while(x)&#123;vis[x]=1;x=fa[x];&#125; _dfs(t1.first,t1.first); ll maxx=0; inc(i,1,n)maxx=max(maxx,sum[i]-sum[p[i]]+min(sum[p[i]]-sum[t1.first],sum[t2.first]-sum[p[i]])); printf("%lld\n",maxx+ans);&#125; 题目描述https://www.lydsy.com/JudgeOnline/problem.php?id=1509 Input第一行是两个整数$N(3&lt;=N&lt;=200000),M$,分别表示居住点总数和街道总数,以下$M$行，每行给出一条街道的信息。第$i+1$行包含整数$Ui、Vi、Ti（1&lt;=U_i, V_i &lt;= N，1 &lt;= T_i&lt;=1000000000)$，表示街道$i$连接居住点$U_i$和$V_i$，并且经过街道$i$需花费$T_i$分钟。街道信息不会重复给出。 Output仅包含整数$T$，即最坏情况下Chris的父母需要花费$T$分钟才能找到Chris。]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1912(树形dp)]]></title>
    <url>%2F2019%2F03%2F10%2Fbzoj1912-%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[题解 $ k=1 $ 必然连接直径两端 我们考虑$ k=2 $的情况 首先明确选的两条路径 选直径是否还是最优的?当然,不管如何考虑选直径带来的优势要大于不选直径 然后对于第二条路的选择 如果第二条路和直径有交边 那么交边还是会经过两次 那么就是让 两条路径并起来的部分减去交的部分长度最长 我们可以考虑将选出来的直径的边权置$-1$ 然后再求一遍树的直径 这样子就必然能得到最优解 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;#define ll long longusing namespace std;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int t)&#123;o-&gt;t=y;o-&gt;v=t;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125; int n,k;bool vis[MAXN];int dis[MAXN];queue&lt;int&gt;que;pii bfs(int x)&#123; inc(i,1,n)vis[i]=dis[i]=0; que.push(x);vis[x]=1; while(!que.empty())&#123; int y=que.front();que.pop(); link(y)&#123; if(!vis[j-&gt;t])vis[j-&gt;t]=1,dis[j-&gt;t]=dis[y]+j-&gt;v,que.push(j-&gt;t); &#125; &#125; pii pos=mp(x,0); inc(i,1,n)if(dis[pos.first]&lt;dis[i])pos=mp(i,dis[i]); return pos;&#125; int fa[MAXN]; void dfs(int x,int pre)&#123; fa[x]=pre; link(x)&#123; if(j-&gt;t==pre)continue; dfs(j-&gt;t,x); &#125;&#125; void _dfs(int x,int pre)&#123; link(x)&#123; if(j-&gt;t==pre)&#123;continue;&#125; if(vis[j-&gt;t])j-&gt;v=-1,_dfs(j-&gt;t,x); &#125;&#125; int dp[MAXN],dp1[MAXN];int st[MAXN],tot;bool cmp(int x,int y)&#123;return x&gt;y;&#125; void __dfs(int x,int pre)&#123; link(x)&#123; if(j-&gt;t==pre)continue; __dfs(j-&gt;t,x); dp[x]=max(dp[x],dp[j-&gt;t]); &#125; tot=0; link(x)&#123; if(j-&gt;t==pre)continue; st[++tot]=dp1[j-&gt;t]+j-&gt;v; &#125; sort(st+1,st+tot+1,cmp); // cout&lt;&lt;x&lt;&lt;"::: "&lt;&lt;tot&lt;&lt;" "&lt;&lt;st[1]&lt;&lt;endl; if(tot==0)return ; else if(tot==1)dp[x]=max(dp[x],st[1]),dp1[x]=st[1]; else dp[x]=max(dp[x],max(st[1]+st[2],st[1])),dp1[x]=st[1]; // cout&lt;&lt;x&lt;&lt;"::: "&lt;&lt;dp[x]&lt;&lt;endl;&#125; int main()&#123; n=read();k=read(); int x,y; inc(i,2,n)x=read(),y=read(),add(x,y,1),add(y,x,1); int ans=2*(n-1); pii t1,t2; t1=bfs(1);t2=bfs(t1.first); ans-=t2.second-1; if(k==2)&#123; inc(i,1,n)vis[i]=0; x=t2.first;y=t1.first; dfs(y,0); while(x)&#123; vis[x]=1; x=fa[x]; &#125; _dfs(y,0);__dfs(y,0); ans-=dp[y]-1; &#125; printf("%d\n",ans); return 0;&#125; 题目描述https://www.lydsy.com/JudgeOnline/problem.php?id=1912 Input第一行包含两个整数$n$,$K(1 ≤ K ≤ 2)$.接下来$n – 1$行，每行两个整数 $a, b$,表示村庄$a$与$b$之间有一条道路$(1 ≤ a, b ≤ n)$。 Output输出一个整数，表示新建了$K$条道路后能达到的最小巡逻距离。]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj4987(树形dp)]]></title>
    <url>%2F2019%2F03%2F09%2Fbzoj4987-%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[题解首先,$\sum_{i=1}^{k-1} dis(a_i,a_{i+1})​$ 最小化 那么对于这$k​$个点的选择可见必然是一个连通子树 可以反证 如何统计价值呢?我们考虑对于一棵树如何遍历每个点让路径和最小 显然是 $ 2sum-len​$ 即2倍路径和减去直径 这样子我们可以设$dp[i][j][0/1/2]​$ 表示在$i​$的子树中选了$j​$个点的联通子树 且直径的三种形态下的最小值 转移留给读者思考 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e3+10;const double eps=1e-8;#define ll long longconst ll inf=2e9;using namespace std;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125;int n,m,sz[MAXN];ll dp[MAXN][MAXN][3];ll ans;int check(int x,int y)&#123; if(x==1&amp;&amp;y==1)return 1; else if(x==0&amp;&amp;y==1)return 1; return 2;&#125;void dfs(int x,int pre)&#123; sz[x]=1; link(x)&#123; if(j-&gt;t==pre)continue; dfs(j-&gt;t,x); dec(i,min(sz[x],m),1)inc(k,0,2)for(int r=1;r+i&lt;=m&amp;&amp;r&lt;=sz[j-&gt;t];r++)inc(p,0,2-k)&#123; dp[x][i+r][k+p]=min(dp[x][i+r][k+p],dp[j-&gt;t][r][p]+dp[x][i][k]+(j-&gt;v)*check(k,p)); &#125; sz[x]+=sz[j-&gt;t]; &#125; ans=min(ans,min(dp[x][m][1],dp[x][m][2]));&#125;int main()&#123; n=read();m=read(); int x,y,z; inc(i,2,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); inc(i,1,n)inc(j,0,m)dp[i][j][0]=dp[i][j][1]=dp[i][j][2]=inf; inc(i,1,n)dp[i][1][1]=dp[i][1][0]=0; ans=inf; dfs(1,0); printf("%lld\n",ans);&#125; 题目描述从前有棵树。找出$K$个点$A_1,A_2,…,A_k$。最小化$\sum_{i=1}^{k-1} dis(a_i,a_{i+1})$ 输入描述第一行两个正整数$n$,$k$,表示数的顶点数和需要选出的点个数。 接下来$n-1$行每行3个非负整数$x$,$y$,$z$，表示从存在一条从$x$到$y$权值为$z$的边 输出描述一行一个整数，表示最小的距离和。]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj3124(树形dp)]]></title>
    <url>%2F2019%2F03%2F09%2Fbzoj3124-%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[题解:我们考虑找出任意一条直径的两个端点$x$,$y$ 对直径上的节点打上标记 对于其他不在直径上的点$v$ 找到其离的最近的标记点$pos$ 我们考虑当前$dis[pos]-dis[x]$与$dis[y]-dis[pos]$的大小关系然后判断$v$是否为分叉直径上的节点 若是则对原标记节点打上标记 最后的答案则为 每条边的权值是否等于分叉直径的条数 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;map&gt;#define mp make_pair#define pb push_back#define pii pair&lt;int,int&gt;#define link(x) for(edge *j=h[x];j;j=j-&gt;next)#define inc(i,l,r) for(int i=l;i&lt;=r;i++)#define dec(i,r,l) for(int i=r;i&gt;=l;i--)const int MAXN=3e5+10;const double eps=1e-8;#define ll long longusing namespace std;struct edge&#123;int t,v;edge*next;&#125;e[MAXN&lt;&lt;1],*h[MAXN],*o=e;void add(int x,int y,int vul)&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;ll read()&#123; ll x=0,f=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(isdigit(ch))x=x*10+ch-'0',ch=getchar(); return x*f;&#125; ll dis[MAXN];int n;bool vis[MAXN];queue&lt;int&gt;que;int bfs(int x)&#123; inc(i,1,n)vis[i]=dis[i]=0; que.push(x);vis[x]=1; while(!que.empty())&#123; int y=que.front();que.pop(); link(y)&#123; if(!vis[j-&gt;t])dis[j-&gt;t]=dis[y]+j-&gt;v,vis[j-&gt;t]=1,que.push(j-&gt;t); &#125; &#125; int pos=x; inc(i,1,n)&#123; if(dis[i]&gt;dis[pos])pos=i; &#125; return pos;&#125; int fa[MAXN],p[MAXN];ll sum[MAXN]; void dfs(int x,int pre)&#123; fa[x]=pre; link(x)&#123; if(j-&gt;t==pre)continue; sum[j-&gt;t]=sum[x]+j-&gt;v; dfs(j-&gt;t,x); &#125;&#125; void work(int y)&#123; inc(i,1,n)vis[i]=0; while(y)&#123; vis[y]=1;y=fa[y]; &#125;&#125; void _dfs(int x,int y)&#123; int k; if(vis[x])k=x;else k=y; p[x]=k; link(x)&#123; if(j-&gt;t==fa[x])continue; _dfs(j-&gt;t,k); &#125;&#125; int ans[MAXN]; void __dfs(int x)&#123; link(x)&#123; if(j-&gt;t==fa[x])continue; __dfs(j-&gt;t); ans[x]+=ans[j-&gt;t]; &#125;&#125; int main()&#123; n=read(); int x,y,z; inc(i,2,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); x=bfs(1);y=bfs(x); dfs(x,0);work(y);_dfs(x,x); ll len=sum[y]-sum[x]; printf("%lld\n",sum[y]-sum[x]); int cnt=0; inc(i,1,n)&#123; if(vis[i])continue; ll t1=sum[i]-sum[p[i]]; if(sum[p[i]]-sum[x]&gt;sum[y]-sum[p[i]])&#123; if(sum[p[i]]-sum[x]+t1==len)ans[p[i]]++,cnt++; &#125; else if(sum[p[i]]-sum[x]&lt;sum[y]-sum[p[i]])&#123; if(sum[y]-sum[p[i]]+t1==len)ans[y]++,ans[p[i]]--,cnt++; &#125; else&#123; if(t1==sum[p[i]]-sum[x])cnt++; &#125; &#125; __dfs(x); int ans1=0; inc(i,1,n)&#123; if(i==x||!vis[i])continue; if(ans[i]==cnt)ans1++; &#125; printf("%d\n",ans1);&#125; 题目描述小Q最近学习了一些图论知识。根据课本，有如下定义。树：无回路且连通的无向图，每条边都有正整数的权值来表示其长度。如果一棵树有$N$个节点，可以证明其有且仅有$N-1$条边。 路径：一棵树上，任意两个节点之间最多有一条简单路径。我们用$dis(a,b)$表示点$a$和点$b$的路径上各边长度之和。称$dis(a,b)$为$a$ ,$b$两个节点间的距离。直径：一棵树上，最长的路径为树的直径。树的直径可能不是唯一的。现在小Q想知道，对于给定的一棵树，其直径的长度是多少，以及有多少条边满足所有的直径都经过该边。 输入描述第一行包含一个整数$N$，表示节点数。接下来$N-1$行，每行三个整数$a$,$ b$,$ c$ ,表示点 $a$和点$b$之间有一条长度为$c$的无向边。 输出描述共两行。第一行一个整数，表示直径的长度。第二行一个整数，表示被所有直径经过的边的数量。]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
</search>
