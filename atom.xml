<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wang9897</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-11T12:11:01.537Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wang9897</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>bzoj2599(点分治)</title>
    <link href="http://yoursite.com/2019/03/11/bzoj2599-%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    <id>http://yoursite.com/2019/03/11/bzoj2599-点分治/</id>
    <published>2019-03-11T12:00:21.000Z</published>
    <updated>2019-03-11T12:11:01.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>讲个鬼故事~~</p><p>第一次xjb写了一个点分治  统计贡献甚至没有去掉同颗子树的情况  骗了75分……..然后对拍写挂了  生成数据从1到n 对拍找不到错 …真是太菜了</p><p>言归正传:</p><p>对于统计贡献 我们可以把重心的儿子的子树一个个合并 然后维护答案就行了</p><p>坑点就是….别把$K$当做$N$ 然后注意别用$memset$来清空  直接用数组记录修改的位置 然后$for$循环清空就行了</p><p>注意还有不存在的情况需要处理</p><p>复杂度 $O(nlogn)$</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> link(x) for(edge *j=h[x];j;j=j-&gt;next)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inc(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,r,l) for(int i=r;i&gt;=l;i--)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NM=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> t,v;edge*next;&#125;e[MAXN&lt;&lt;<span class="number">1</span>],*h[MAXN],*o=e;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> vul)</span></span>&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;</span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,K;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line">ll dis[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];</span><br><span class="line"><span class="keyword">int</span> base,key,rt;</span><br><span class="line"><span class="keyword">int</span> sz[MAXN],maxx[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">    sz[x]=<span class="number">1</span>;maxx[x]=<span class="number">0</span>;</span><br><span class="line">    link(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(j-&gt;t==pre||vis[j-&gt;t])<span class="keyword">continue</span>;</span><br><span class="line">get_root(j-&gt;t,x);</span><br><span class="line">sz[x]+=sz[j-&gt;t];maxx[x]=max(maxx[x],sz[j-&gt;t]);</span><br><span class="line">    &#125;</span><br><span class="line">    maxx[x]=max(maxx[x],base-sz[x]);</span><br><span class="line">    <span class="keyword">if</span>(key&gt;maxx[x])key=maxx[x],rt=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> st[MAXN],tot,ans,St[MAXN],tot1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[NM],Num[NM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dis[x]&lt;=K)st[++tot]=dis[x],num[dis[x]]=min(num[dis[x]],cnt[x]),St[++tot1]=dis[x];</span><br><span class="line">    link(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(j-&gt;t==pre||vis[j-&gt;t])<span class="keyword">continue</span>;</span><br><span class="line">dis[j-&gt;t]=dis[x]+j-&gt;v;cnt[j-&gt;t]=cnt[x]+<span class="number">1</span>;</span><br><span class="line">dfs(j-&gt;t,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    vis[x]=<span class="number">1</span>;tot1=<span class="number">0</span>;Num[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    link(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j-&gt;t])<span class="keyword">continue</span>;</span><br><span class="line">tot=<span class="number">0</span>;dis[j-&gt;t]=j-&gt;v;cnt[j-&gt;t]=<span class="number">1</span>;dfs(j-&gt;t,x);</span><br><span class="line">inc(i,<span class="number">1</span>,tot)ans=min(ans,num[st[i]]+Num[K-st[i]]);</span><br><span class="line">inc(i,<span class="number">1</span>,tot)Num[st[i]]=min(Num[st[i]],num[st[i]]),num[st[i]]=inf;</span><br><span class="line">    &#125;</span><br><span class="line">    inc(i,<span class="number">1</span>,tot1)Num[St[i]]=inf;</span><br><span class="line">    Num[<span class="number">0</span>]=inf;</span><br><span class="line">    link(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j-&gt;t])<span class="keyword">continue</span>;</span><br><span class="line">key=inf;base=sz[j-&gt;t];get_root(j-&gt;t,<span class="number">0</span>);</span><br><span class="line">solve(rt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read();K=read();</span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">    inc(i,<span class="number">1</span>,K)num[i]=Num[i]=inf;</span><br><span class="line">    inc(i,<span class="number">2</span>,n)x=read()+<span class="number">1</span>,y=read()+<span class="number">1</span>,z=read(),add(x,y,z),add(y,x,z);</span><br><span class="line">    ans=inf;key=inf;base=n;get_root(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    solve(rt);</span><br><span class="line">    <span class="keyword">if</span>(ans==inf)<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给一棵树,每条边有权.求一条简单路径,权值和等于$K$,且边的数量最小.$N &lt;= 200000$,$ K &lt;= 1000000$</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行 两个整数 $n, k$<br>第$二…….N$行 每行三个整数 表示一条无向边的两端和权值 (注意点的编号从0开始)</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>一个整数 表示最小边数量 如果不存在这样的路径 输出$-1​$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;p&gt;讲个鬼故事~~&lt;/p&gt;
&lt;p&gt;第一次xjb写了一个点分治  统计贡献甚至没有去掉同颗子树的情况  骗了75分……..然后对拍写挂了  生成数
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="点分治" scheme="http://yoursite.com/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>bzoj2152(点分治)</title>
    <link href="http://yoursite.com/2019/03/11/bzoj2152-%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    <id>http://yoursite.com/2019/03/11/bzoj2152-点分治/</id>
    <published>2019-03-11T07:37:20.000Z</published>
    <updated>2019-03-11T07:50:48.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>点分治模板题</p><p>不同的是 我们不需要sort 也不需要去重</p><p>对于每个子树重心做一个树$dp$即可 $dp[x][y]$表示x的子树中到x距离模3后y的个数</p><p>然后对于每个子树重心 合并维护答案即可</p><p>$复杂度O(nlogn)$</p><a id="more"></a><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> link(x) for(edge *j=h[x];j;j=j-&gt;next)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inc(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,r,l) for(int i=r;i&gt;=l;i--)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> t,v;edge*next;&#125;e[MAXN&lt;&lt;<span class="number">1</span>],*h[MAXN],*o=e;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> vul)</span></span>&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;</span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> base,key,pos,sz[MAXN],maxx[MAXN],rt;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">    sz[x]=<span class="number">1</span>;maxx[x]=<span class="number">0</span>;</span><br><span class="line">    link(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j-&gt;t]||j-&gt;t==pre)<span class="keyword">continue</span>;</span><br><span class="line">get_root(j-&gt;t,x);</span><br><span class="line">sz[x]+=sz[j-&gt;t];maxx[x]=max(maxx[x],sz[j-&gt;t]);</span><br><span class="line">    &#125;</span><br><span class="line">    maxx[x]=max(maxx[x],base-sz[x]);</span><br><span class="line">    <span class="keyword">if</span>(key&gt;maxx[x])key=maxx[x],rt=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t[MAXN][<span class="number">4</span>];</span><br><span class="line">ll dis[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">    t[x][<span class="number">0</span>]=t[x][<span class="number">1</span>]=t[x][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">    t[x][dis[x]%<span class="number">3</span>]++;</span><br><span class="line">    link(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j-&gt;t]||j-&gt;t==pre)<span class="keyword">continue</span>;</span><br><span class="line">dis[j-&gt;t]=dis[x]+j-&gt;v;</span><br><span class="line">dfs(j-&gt;t,x);</span><br><span class="line">t[x][<span class="number">0</span>]+=t[j-&gt;t][<span class="number">0</span>];t[x][<span class="number">1</span>]+=t[j-&gt;t][<span class="number">1</span>];t[x][<span class="number">2</span>]+=t[j-&gt;t][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">    vis[x]=<span class="number">1</span>;dis[x]=<span class="number">0</span>;</span><br><span class="line">    dfs(x,<span class="number">0</span>);</span><br><span class="line">    t[x][<span class="number">0</span>]=t[x][<span class="number">1</span>]=t[x][<span class="number">2</span>]=<span class="number">0</span>;t[x][<span class="number">0</span>]++;</span><br><span class="line">    link(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j-&gt;t]||j-&gt;t==pre)<span class="keyword">continue</span>;</span><br><span class="line">ans+=<span class="number">1l</span>l*t[x][<span class="number">0</span>]*t[j-&gt;t][<span class="number">0</span>];</span><br><span class="line">ans+=<span class="number">1l</span>l*t[x][<span class="number">1</span>]*t[j-&gt;t][<span class="number">2</span>];</span><br><span class="line">ans+=<span class="number">1l</span>l*t[x][<span class="number">2</span>]*t[j-&gt;t][<span class="number">1</span>];</span><br><span class="line">t[x][<span class="number">0</span>]+=t[j-&gt;t][<span class="number">0</span>];t[x][<span class="number">1</span>]+=t[j-&gt;t][<span class="number">1</span>];t[x][<span class="number">2</span>]+=t[j-&gt;t][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    link(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j-&gt;t]||j-&gt;t==pre)<span class="keyword">continue</span>;</span><br><span class="line">key=inf;base=sz[j-&gt;t];get_root(j-&gt;t,x);</span><br><span class="line">solve(rt,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read();</span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">    inc(i,<span class="number">2</span>,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z);</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    base=n;key=inf;get_root(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    solve(rt,<span class="number">0</span>);</span><br><span class="line">    ll t1=<span class="number">2</span>*ans+n;ll t2=<span class="number">1l</span>l*n*n;</span><br><span class="line">    ll t=__gcd(t1,t2);t1/=t;t2/=t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld/%lld\n"</span>,t1,t2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>聪聪和可可是兄弟俩，他们俩经常为了一些琐事打起来，例如家中只剩下最后一根冰棍而两人都想吃、两个人都想玩儿电脑（可是他们家只有一台电脑）……遇到这种问题，一般情况下石头剪刀布就好了，可是他们已经玩儿腻了这种低智商的游戏。他们的爸爸快被他们的争吵烦死了，所以他发明了一个新游戏：由爸爸在纸上画$n$个“点”，并用$n-1$条“边”把这$n$个“点”恰好连通（其实这就是一棵树）。并且每条“边”上都有一个数。接下来由聪聪和可可分别随即选一个点（当然他们选点时是看不到这棵树的），如果两个点之间所有边上数的和加起来恰好是$3$的倍数，则判聪聪赢，否则可可赢。聪聪非常爱思考问题，在每次游戏后都会仔细研究这棵树，希望知道对于这张图自己的获胜概率是多少。现请你帮忙求出这个值以验证聪聪的答案是否正确。</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入的第1行包含1个正整数$n$。后面$n-1$行，每行$3$个整数$x、y、w$，表示$x$号点和$y$号点之间有一条边，上面的数是$w$。</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>以即约分数形式输出这个概率（即$“a/b”$的形式，其中$a$和$b$必须互质。如果概率为$1$，输出$“1/1”$）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;p&gt;点分治模板题&lt;/p&gt;
&lt;p&gt;不同的是 我们不需要sort 也不需要去重&lt;/p&gt;
&lt;p&gt;对于每个子树重心做一个树$dp$即可 $dp[x][y]$表示x的子树中到x距离模3后y的个数&lt;/p&gt;
&lt;p&gt;然后对于每个子树重心 合并维护答案即可&lt;/p&gt;
&lt;p&gt;$复杂度O(nlogn)$&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="点分治" scheme="http://yoursite.com/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>bzoj3365(点分治)</title>
    <link href="http://yoursite.com/2019/03/11/bzoj3365-%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    <id>http://yoursite.com/2019/03/11/bzoj3365-点分治/</id>
    <published>2019-03-11T06:51:53.000Z</published>
    <updated>2019-03-11T06:53:36.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>同上题</p><a id="more"></a><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> link(x) for(edge *j=h[x];j;j=j-&gt;next)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inc(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,r,l) for(int i=r;i&gt;=l;i--)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> t,v;edge*next;&#125;e[MAXN&lt;&lt;<span class="number">1</span>],*h[MAXN],*o=e;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> vul)</span></span>&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;</span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,K;</span><br><span class="line"><span class="keyword">int</span> rt,base,sz[MAXN],maxx[MAXN],key;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">    sz[x]=<span class="number">1</span>;maxx[x]=<span class="number">0</span>;</span><br><span class="line">    link(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(j-&gt;t==pre||vis[j-&gt;t])<span class="keyword">continue</span>;</span><br><span class="line">get_root(j-&gt;t,x);</span><br><span class="line">sz[x]+=sz[j-&gt;t];maxx[x]=max(maxx[x],sz[j-&gt;t]);</span><br><span class="line">    &#125;</span><br><span class="line">    maxx[x]=max(maxx[x],base-sz[x]);</span><br><span class="line">    <span class="keyword">if</span>(maxx[x]&lt;key)key=maxx[x],rt=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll st[MAXN],dis[MAXN];<span class="keyword">int</span> tot,num[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_deep</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">    num[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!pre)st[++tot]=dis[x];</span><br><span class="line">    link(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(j-&gt;t==pre||vis[j-&gt;t])<span class="keyword">continue</span>;</span><br><span class="line">dis[j-&gt;t]=dis[x]+j-&gt;v;st[++tot]=dis[j-&gt;t];</span><br><span class="line">get_deep(j-&gt;t,x);</span><br><span class="line">num[x]+=num[j-&gt;t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x,ll dist)</span></span>&#123;</span><br><span class="line">    dis[x]=dist;tot=<span class="number">0</span>;get_deep(x,<span class="number">0</span>);</span><br><span class="line">    sort(st+<span class="number">1</span>,st+tot+<span class="number">1</span>);</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    inc(i,<span class="number">1</span>,tot)&#123;</span><br><span class="line"><span class="keyword">int</span> l=i+<span class="number">1</span>;<span class="keyword">int</span> r=tot;<span class="keyword">int</span> ans1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(st[i]+st[mid]&lt;=K)ans1=mid,l=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!ans1)<span class="keyword">continue</span>;</span><br><span class="line">sum+=ans1-i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    vis[x]=<span class="number">1</span>;ans+=get_sum(x,<span class="number">0</span>);</span><br><span class="line">    link(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(j-&gt;t==y||vis[j-&gt;t])<span class="keyword">continue</span>;</span><br><span class="line">key=inf;base=num[j-&gt;t];get_root(j-&gt;t,x);ans-=get_sum(j-&gt;t,j-&gt;v);</span><br><span class="line">solve(rt,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    n=read();<span class="keyword">int</span> m=read();</span><br><span class="line">    inc(i,<span class="number">2</span>,n)<span class="built_in">scanf</span>(<span class="string">"%d %d %d %c"</span>,&amp;x,&amp;y,&amp;z,&amp;ch),add(x,y,z),add(y,x,z);</span><br><span class="line">    K=read();</span><br><span class="line">    key=inf;base=n;get_root(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    solve(rt,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3365" target="_blank" rel="noopener">https://www.lydsy.com/JudgeOnline/problem.php?id=3365</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;p&gt;同上题&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="点分治" scheme="http://yoursite.com/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>bzoj1468(点分治)</title>
    <link href="http://yoursite.com/2019/03/11/bzoj1468-%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    <id>http://yoursite.com/2019/03/11/bzoj1468-点分治/</id>
    <published>2019-03-11T06:30:28.000Z</published>
    <updated>2019-03-11T06:43:47.519Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>点分治模板题  </p><p>第一次写点分治 那就把我的心酸证明历程也记录下吧</p><p>首先:前置知识点  树的重心(当$x$为根时,其子树节点的$size$的最大值最小)</p><p>然后每次以子树重心分治 保证分治层数不超过$logn$层</p><p>证明: 我们假如其$size_u&gt;size/2$那么 我们必然可以往其$size$较大的子树节点继续选择 那么这个点就不在是重心 </p><p>然后:考虑如何统计点对贡献 我们可以处理出当前子树节点到$rt$的距离 然后$sort$以后双指针/二分查询贡献 但是这样会把子树节点内的点对重复计数 所以每次需要去重一下 </p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> link(x) for(edge *j=h[x];j;j=j-&gt;next)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inc(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,r,l) for(int i=r;i&gt;=l;i--)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> t,v;edge*next;&#125;e[MAXN&lt;&lt;<span class="number">1</span>],*h[MAXN],*o=e;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> vul)</span></span>&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;</span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,K;</span><br><span class="line"><span class="keyword">int</span> rt,base,sz[MAXN],maxx[MAXN],key;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">    sz[x]=<span class="number">1</span>;maxx[x]=<span class="number">0</span>;</span><br><span class="line">    link(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(j-&gt;t==pre||vis[j-&gt;t])<span class="keyword">continue</span>;</span><br><span class="line">get_root(j-&gt;t,x);</span><br><span class="line">sz[x]+=sz[j-&gt;t];maxx[x]=max(maxx[x],sz[j-&gt;t]);</span><br><span class="line">    &#125;</span><br><span class="line">    maxx[x]=max(maxx[x],base-sz[x]);</span><br><span class="line">    <span class="keyword">if</span>(maxx[x]&lt;key)key=maxx[x],rt=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll st[MAXN],dis[MAXN];<span class="keyword">int</span> tot,num[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_deep</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">    num[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!pre)st[++tot]=dis[x];</span><br><span class="line">    link(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(j-&gt;t==pre||vis[j-&gt;t])<span class="keyword">continue</span>;</span><br><span class="line">dis[j-&gt;t]=dis[x]+j-&gt;v;st[++tot]=dis[j-&gt;t];</span><br><span class="line">get_deep(j-&gt;t,x);</span><br><span class="line">num[x]+=num[j-&gt;t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> x,ll dist)</span></span>&#123;</span><br><span class="line">    dis[x]=dist;tot=<span class="number">0</span>;get_deep(x,<span class="number">0</span>);</span><br><span class="line">    sort(st+<span class="number">1</span>,st+tot+<span class="number">1</span>);</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    inc(i,<span class="number">1</span>,tot)&#123;</span><br><span class="line"><span class="keyword">int</span> l=i+<span class="number">1</span>;<span class="keyword">int</span> r=tot;<span class="keyword">int</span> ans1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(st[i]+st[mid]&lt;=K)ans1=mid,l=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!ans1)<span class="keyword">continue</span>;</span><br><span class="line">sum+=ans1-i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    vis[x]=<span class="number">1</span>;ans+=get_sum(x,<span class="number">0</span>);</span><br><span class="line">    link(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(j-&gt;t==y||vis[j-&gt;t])<span class="keyword">continue</span>;</span><br><span class="line">key=inf;base=num[j-&gt;t];get_root(j-&gt;t,x);ans-=get_sum(j-&gt;t,j-&gt;v);</span><br><span class="line">solve(rt,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">    n=read();</span><br><span class="line">    inc(i,<span class="number">2</span>,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z);</span><br><span class="line">    K=read();</span><br><span class="line">    key=inf;base=n;get_root(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    solve(rt,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一棵$TREE$,以及这棵树上边的距离.问有多少对点它们两者间的距离小于等于$K$</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>$N(n&lt;=40000)$接下来$n-1$行边描述管道，按照题目中写的输入 接下来是$k$</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>一行，有多少对点之间的距离小于等于$k$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;p&gt;点分治模板题  &lt;/p&gt;
&lt;p&gt;第一次写点分治 那就把我的心酸证明历程也记录下吧&lt;/p&gt;
&lt;p&gt;首先:前置知识点  树的重心(当$x$为根时
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="点分治" scheme="http://yoursite.com/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>bzoj2282树形dp</title>
    <link href="http://yoursite.com/2019/03/10/bzoj2282-%E6%A0%91%E5%BD%A2dp/"/>
    <id>http://yoursite.com/2019/03/10/bzoj2282-树形dp/</id>
    <published>2019-03-10T13:10:58.000Z</published>
    <updated>2019-03-11T06:57:01.983Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先路径的选择应该是直径的某一段区间…证明略(虽然我也是直观感受的)</p><p>然后我们考虑对直径上区间的选择 对于区间[l,r]的价值为$max(dis(直径左端点,l),max(dis(直径右端点,r),子区间上的价值))$ </p><p>当$l$保持不变,$r$增加时,区间价值单调不增加,所以我们应该对于每个左端点$l$,找到最大r满足条件 然后统计</p><p>然后对于子区间价值的维护 我们可以找到每个点到离其最近直径上点距离的最大值更新并维护直径上点的价值</p><p>然后因为我单调队列 写挂了  就直接用线段树查询区间最大值即可</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> link(x) for(edge *j=h[x];j;j=j-&gt;next)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inc(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,r,l) for(int i=r;i&gt;=l;i--)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> t,v;edge*next;&#125;e[MAXN&lt;&lt;<span class="number">1</span>],*h[MAXN],*o=e;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> vul)</span></span>&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;</span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> st[MAXN],tot,p[MAXN],dis[MAXN],s;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;que;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    inc(i,<span class="number">1</span>,n)dis[i]=vis[i]=<span class="number">0</span>;</span><br><span class="line">    vis[x]=<span class="number">1</span>;que.push(x);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">    <span class="keyword">int</span> y=que.front();que.pop();</span><br><span class="line">    link(y)<span class="keyword">if</span>(!vis[j-&gt;t])vis[j-&gt;t]=<span class="number">1</span>,dis[j-&gt;t]=dis[y]+j-&gt;v,que.push(j-&gt;t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pos=x;</span><br><span class="line">    inc(i,<span class="number">1</span>,n)<span class="keyword">if</span>(dis[pos]&lt;dis[i])pos=i;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> sum[MAXN],fa[MAXN],ans[MAXN],key[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">    fa[x]=pre;</span><br><span class="line">    link(x)<span class="keyword">if</span>(j-&gt;t!=pre)sum[j-&gt;t]=sum[x]+j-&gt;v,key[j-&gt;t]=j-&gt;v,dfs(j-&gt;t,x);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> _dfs(<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(vis[x])k=x;<span class="keyword">else</span> k=y;</span><br><span class="line">    p[x]=k;</span><br><span class="line">    link(x)<span class="keyword">if</span>(j-&gt;t!=fa[x])_dfs(j-&gt;t,k);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> maxx[MAXN&lt;&lt;<span class="number">2</span>],R[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">built</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;maxx[x]=ans[st[l]];<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    built(x&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    built(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    maxx[x]=max(maxx[x&lt;&lt;<span class="number">1</span>],maxx[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> Maxx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ql,<span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;Maxx=max(Maxx,maxx[x]);<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=mid)query(x&lt;&lt;<span class="number">1</span>,l,mid,ql,qr);</span><br><span class="line">    <span class="keyword">if</span>(qr&gt;mid)query(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,ql,qr);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read();s=read();</span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">    inc(i,<span class="number">2</span>,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z);</span><br><span class="line">    x=bfs(<span class="number">1</span>);y=bfs(x);</span><br><span class="line">    dfs(x,<span class="number">0</span>);tot=<span class="number">0</span>;</span><br><span class="line">    inc(i,<span class="number">1</span>,n)vis[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k1=y;</span><br><span class="line">    <span class="keyword">while</span>(y)st[++tot]=y,vis[y]=<span class="number">1</span>,y=fa[y];</span><br><span class="line">    y=k1;</span><br><span class="line">    _dfs(x,x);</span><br><span class="line">    inc(i,<span class="number">1</span>,n)ans[p[i]]=max(ans[p[i]],sum[i]-sum[p[i]]);</span><br><span class="line">    built(<span class="number">1</span>,<span class="number">1</span>,tot);</span><br><span class="line">    inc(i,<span class="number">1</span>,tot)R[i]=R[i<span class="number">-1</span>]+key[st[i]];</span><br><span class="line">    <span class="keyword">int</span> ans2=inf;</span><br><span class="line">   <span class="comment">// cout&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;endl;</span></span><br><span class="line">    inc(i,<span class="number">1</span>,tot)&#123;</span><br><span class="line">    <span class="keyword">int</span> l=i;<span class="keyword">int</span> r=tot;<span class="keyword">int</span> ans1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(R[mid]-R[i<span class="number">-1</span>]&lt;=s)ans1=mid,l=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!ans1)ans1=i;<span class="keyword">else</span> ans1=min(tot,ans1+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//  cout&lt;&lt;i&lt;&lt;"::: "&lt;&lt;ans1&lt;&lt;endl;</span></span><br><span class="line">    Maxx=<span class="number">0</span>;query(<span class="number">1</span>,<span class="number">1</span>,tot,i,ans1);</span><br><span class="line">    ans2=min(ans2,max(Maxx,max(sum[y]-sum[st[i]],sum[st[ans1]]-sum[x])));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>某个国家有$n$个城市，这$n$个城市中任意两个都连通且有唯一一条路径，每条连通两个城市的道路的长度为$z_i(z_i&lt;=1000)$。</p><p>这个国家的人对火焰有超越宇宙的热情，所以这个国家最兴旺的行业是消防业。由于政府对国民的热情忍无可忍（大量的消防经费开销）可是却又无可奈何（总统竞选的国民支持率），所以只能想尽方法提高消防能力。</p><p>现在这个国家的经费足以在一条边长度和不超过$s$的路径（两端都是城市）上建立消防枢纽，为了尽量提高枢纽的利用率，要求其他所有城市到这条路径的距离的最大值最小。</p><p>你受命监管这个项目，你当然需要知道应该把枢纽建立在什么位置上。</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入包含$n$行：<br>第$1$行，两个正整数$n$和$s$，中间用一个空格隔开。其中$n$为城市的个数,$s$为路径长度的上界。设结点编号以此为$1，2，……，n$。<br>从第$2$行到第$n$行，每行给出$3$个用空格隔开的正整数，依次表示每一条边的两个端点编号和长度。例如，$“2 4 7”$表示连接结点$2$与$4$的边的长度为$7$。</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出包含一个非负整数，即所有城市到选择的路径的最大值，当然这个最大值必须是所有方案中最小的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;p&gt;首先路径的选择应该是直径的某一段区间…证明略(虽然我也是直观感受的)&lt;/p&gt;
&lt;p&gt;然后我们考虑对直径上区间的选择 对于区间[l,r]的价值
      
    
    </summary>
    
      <category term="dp" scheme="http://yoursite.com/categories/dp/"/>
    
    
      <category term="树形dp" scheme="http://yoursite.com/tags/%E6%A0%91%E5%BD%A2dp/"/>
    
  </entry>
  
  <entry>
    <title>bzoj1509(树形dp)</title>
    <link href="http://yoursite.com/2019/03/10/bzoj1509-%E6%A0%91%E5%BD%A2dp/"/>
    <id>http://yoursite.com/2019/03/10/bzoj1509-树形dp/</id>
    <published>2019-03-10T06:20:46.000Z</published>
    <updated>2019-03-10T06:33:40.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>从一棵树里面找三个点$x,y,z$,从点$x$出发,先到另外两个点中离$x$较近的点,然后再到剩下那个点的路径和最大.首先对于直径两端点是必然选择,然后枚举起点,统计答案即可</p><a id="more"></a><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,long long&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> link(x) for(edge *j=h[x];j;j=j-&gt;next)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inc(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,r,l) for(int i=r;i&gt;=l;i--)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> t,v;edge*next;&#125;e[MAXN&lt;&lt;<span class="number">1</span>],*h[MAXN],*o=e;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> vul)</span></span>&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;</span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">ll dis[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;que;</span><br><span class="line"><span class="function">pii <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    inc(i,<span class="number">1</span>,n)dis[i]=vis[i]=<span class="number">0</span>;</span><br><span class="line">    que.push(x);vis[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> y=que.front();que.pop();</span><br><span class="line">link(y)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[j-&gt;t])vis[j-&gt;t]=<span class="number">1</span>,dis[j-&gt;t]=dis[y]+j-&gt;v,que.push(j-&gt;t);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pii pos=mp(x,<span class="number">0</span>);</span><br><span class="line">    inc(i,<span class="number">1</span>,n)<span class="keyword">if</span>(dis[pos.first]&lt;dis[i])pos=mp(i,dis[i]);</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">    fa[x]=pre;</span><br><span class="line">    link(x)<span class="keyword">if</span>(j-&gt;t!=pre)dfs(j-&gt;t,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[MAXN];ll sum[MAXN];</span><br><span class="line"><span class="keyword">void</span> _dfs(<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(vis[x])k=x;<span class="keyword">else</span> k=y;</span><br><span class="line">    p[x]=k;</span><br><span class="line">    link(x)<span class="keyword">if</span>(j-&gt;t!=fa[x])sum[j-&gt;t]=sum[x]+j-&gt;v,_dfs(j-&gt;t,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read();m=read();</span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">    inc(i,<span class="number">2</span>,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z);</span><br><span class="line">    pii t1=bfs(<span class="number">1</span>);</span><br><span class="line">    pii t2=bfs(t1.first);</span><br><span class="line">    ll ans=t2.second;</span><br><span class="line">    dfs(t1.first,<span class="number">0</span>);x=t2.first;</span><br><span class="line">    inc(i,<span class="number">1</span>,n)vis[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;vis[x]=<span class="number">1</span>;x=fa[x];&#125;</span><br><span class="line">    _dfs(t1.first,t1.first);</span><br><span class="line">    ll maxx=<span class="number">0</span>;</span><br><span class="line">    inc(i,<span class="number">1</span>,n)maxx=max(maxx,sum[i]-sum[p[i]]+min(sum[p[i]]-sum[t1.first],sum[t2.first]-sum[p[i]]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,maxx+ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1509" target="_blank" rel="noopener">https://www.lydsy.com/JudgeOnline/problem.php?id=1509</a></p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行是两个整数$N(3&lt;=N&lt;=200000),M$,分别表示居住点总数和街道总数,以下$M$行，每行给出一条街道的信息。第$i+1$行包含整数$Ui、Vi、Ti（1&lt;=U_i, V_i &lt;= N，1 &lt;= T_i&lt;=1000000000)$，表示街道$i$连接居住点$U_i$和$V_i$，并且经过街道$i$需花费$T_i$分钟。街道信息不会重复给出。</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>仅包含整数$T$，即最坏情况下Chris的父母需要花费$T$分钟才能找到Chris。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;p&gt;从一棵树里面找三个点$x,y,z$,从点$x$出发,先到另外两个点中离$x$较近的点,然后再到剩下那个点的路径和最大.首先对于直径两端点是必然选择,然后枚举起点,统计答案即可&lt;/p&gt;
    
    </summary>
    
      <category term="dp" scheme="http://yoursite.com/categories/dp/"/>
    
    
      <category term="树形dp" scheme="http://yoursite.com/tags/%E6%A0%91%E5%BD%A2dp/"/>
    
  </entry>
  
  <entry>
    <title>bzoj1912(树形dp)</title>
    <link href="http://yoursite.com/2019/03/10/bzoj1912-%E6%A0%91%E5%BD%A2dp/"/>
    <id>http://yoursite.com/2019/03/10/bzoj1912-树形dp/</id>
    <published>2019-03-10T04:54:26.000Z</published>
    <updated>2019-03-10T05:03:38.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul><li>$ k=1 $ 必然连接直径两端</li><li>我们考虑$ k=2 $的情况 首先明确选的两条路径 选直径是否还是最优的?当然,不管如何考虑选直径带来的优势要大于不选直径  然后对于第二条路的选择 如果第二条路和直径有交边 那么交边还是会经过两次 那么就是让 两条路径并起来的部分减去交的部分长度最长 我们可以考虑将选出来的直径的边权置$-1$ 然后再求一遍树的直径 这样子就必然能得到最优解</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> link(x) for(edge *j=h[x];j;j=j-&gt;next)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inc(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,r,l) for(int i=r;i&gt;=l;i--)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> t,v;edge*next;&#125;e[MAXN&lt;&lt;<span class="number">1</span>],*h[MAXN],*o=e;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> t)</span></span>&#123;o-&gt;t=y;o-&gt;v=t;o-&gt;next=h[x];h[x]=o++;&#125;</span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> dis[MAXN];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;que;</span><br><span class="line"><span class="function">pii <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    inc(i,<span class="number">1</span>,n)vis[i]=dis[i]=<span class="number">0</span>;</span><br><span class="line">    que.push(x);vis[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">    <span class="keyword">int</span> y=que.front();que.pop();</span><br><span class="line">    link(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[j-&gt;t])vis[j-&gt;t]=<span class="number">1</span>,dis[j-&gt;t]=dis[y]+j-&gt;v,que.push(j-&gt;t);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pii pos=mp(x,<span class="number">0</span>);</span><br><span class="line">    inc(i,<span class="number">1</span>,n)<span class="keyword">if</span>(dis[pos.first]&lt;dis[i])pos=mp(i,dis[i]);</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> fa[MAXN];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">    fa[x]=pre;</span><br><span class="line">    link(x)&#123;</span><br><span class="line">    <span class="keyword">if</span>(j-&gt;t==pre)<span class="keyword">continue</span>;</span><br><span class="line">    dfs(j-&gt;t,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> _dfs(<span class="keyword">int</span> x,<span class="keyword">int</span> pre)&#123;</span><br><span class="line">    link(x)&#123;</span><br><span class="line">    <span class="keyword">if</span>(j-&gt;t==pre)&#123;<span class="keyword">continue</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(vis[j-&gt;t])j-&gt;v=<span class="number">-1</span>,_dfs(j-&gt;t,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> dp[MAXN],dp1[MAXN];</span><br><span class="line"><span class="keyword">int</span> st[MAXN],tot;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&gt;y;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> __dfs(<span class="keyword">int</span> x,<span class="keyword">int</span> pre)&#123;</span><br><span class="line">    link(x)&#123;</span><br><span class="line">    <span class="keyword">if</span>(j-&gt;t==pre)<span class="keyword">continue</span>;</span><br><span class="line">    __dfs(j-&gt;t,x);</span><br><span class="line">    dp[x]=max(dp[x],dp[j-&gt;t]);</span><br><span class="line">    &#125;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    link(x)&#123;</span><br><span class="line">    <span class="keyword">if</span>(j-&gt;t==pre)<span class="keyword">continue</span>;</span><br><span class="line">    st[++tot]=dp1[j-&gt;t]+j-&gt;v;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(st+<span class="number">1</span>,st+tot+<span class="number">1</span>,cmp);</span><br><span class="line"> <span class="comment">//   cout&lt;&lt;x&lt;&lt;"::: "&lt;&lt;tot&lt;&lt;" "&lt;&lt;st[1]&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(tot==<span class="number">0</span>)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tot==<span class="number">1</span>)dp[x]=max(dp[x],st[<span class="number">1</span>]),dp1[x]=st[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">else</span> dp[x]=max(dp[x],max(st[<span class="number">1</span>]+st[<span class="number">2</span>],st[<span class="number">1</span>])),dp1[x]=st[<span class="number">1</span>];</span><br><span class="line"> <span class="comment">//   cout&lt;&lt;x&lt;&lt;"::: "&lt;&lt;dp[x]&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read();k=read();</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    inc(i,<span class="number">2</span>,n)x=read(),y=read(),add(x,y,<span class="number">1</span>),add(y,x,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">2</span>*(n<span class="number">-1</span>);</span><br><span class="line">    pii t1,t2;</span><br><span class="line">    t1=bfs(<span class="number">1</span>);t2=bfs(t1.first);</span><br><span class="line">    ans-=t2.second<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">2</span>)&#123;</span><br><span class="line">    inc(i,<span class="number">1</span>,n)vis[i]=<span class="number">0</span>;</span><br><span class="line">    x=t2.first;y=t1.first;</span><br><span class="line">    dfs(y,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        vis[x]=<span class="number">1</span>;</span><br><span class="line">        x=fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">    _dfs(y,<span class="number">0</span>);__dfs(y,<span class="number">0</span>);</span><br><span class="line">    ans-=dp[y]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1912" target="_blank" rel="noopener">https://www.lydsy.com/JudgeOnline/problem.php?id=1912</a></p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行包含两个整数$n$,$K(1 ≤ K ≤ 2)$.接下来$n – 1$行，每行两个整数 $a, b$,表示村庄$a$与$b$之间有一条道路$(1 ≤ a, b ≤ n)$。</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出一个整数，表示新建了$K$条道路后能达到的最小巡逻距离。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;$ k=1 $ 必然连接直径两端&lt;/li&gt;
&lt;li&gt;我们考虑$ k=2 $的情况 首先明确选的两条路径 选直径是否还是最优的?当
      
    
    </summary>
    
      <category term="dp" scheme="http://yoursite.com/categories/dp/"/>
    
    
      <category term="树形dp" scheme="http://yoursite.com/tags/%E6%A0%91%E5%BD%A2dp/"/>
    
  </entry>
  
  <entry>
    <title>bzoj4987(树形dp)</title>
    <link href="http://yoursite.com/2019/03/09/bzoj4987-%E6%A0%91%E5%BD%A2dp/"/>
    <id>http://yoursite.com/2019/03/09/bzoj4987-树形dp/</id>
    <published>2019-03-09T06:24:44.000Z</published>
    <updated>2019-03-09T06:43:03.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先,$\sum_{i=1}^{k-1} dis(a_i,a_{i+1})​$ 最小化 那么对于这$k​$个点的选择可见必然是一个连通子树 可以反证 如何统计价值呢?我们考虑对于一棵树如何遍历每个点让路径和最小 显然是 $ 2sum-len​$ 即2倍路径和减去直径 这样子我们可以设$dp[i][j][0/1/2]​$ 表示在$i​$的子树中选了$j​$个点的联通子树 且直径的三种形态下的最小值 转移留给读者思考</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> link(x) for(edge *j=h[x];j;j=j-&gt;next)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inc(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,r,l) for(int i=r;i&gt;=l;i--)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">3e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> t,v;edge*next;&#125;e[MAXN&lt;&lt;<span class="number">1</span>],*h[MAXN],*o=e;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> vul)</span></span>&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;</span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,sz[MAXN];</span><br><span class="line">ll dp[MAXN][MAXN][<span class="number">3</span>];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>&amp;&amp;y==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">    sz[x]=<span class="number">1</span>;</span><br><span class="line">    link(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(j-&gt;t==pre)<span class="keyword">continue</span>;</span><br><span class="line">dfs(j-&gt;t,x);</span><br><span class="line">dec(i,min(sz[x],m),<span class="number">1</span>)inc(k,<span class="number">0</span>,<span class="number">2</span>)<span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">1</span>;r+i&lt;=m&amp;&amp;r&lt;=sz[j-&gt;t];r++)inc(p,<span class="number">0</span>,<span class="number">2</span>-k)&#123;</span><br><span class="line">    dp[x][i+r][k+p]=min(dp[x][i+r][k+p],dp[j-&gt;t][r][p]+dp[x][i][k]+(j-&gt;v)*check(k,p));</span><br><span class="line">&#125;</span><br><span class="line">sz[x]+=sz[j-&gt;t];</span><br><span class="line">    &#125;</span><br><span class="line">    ans=min(ans,min(dp[x][m][<span class="number">1</span>],dp[x][m][<span class="number">2</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read();m=read();</span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">    inc(i,<span class="number">2</span>,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z);</span><br><span class="line">    inc(i,<span class="number">1</span>,n)inc(j,<span class="number">0</span>,m)dp[i][j][<span class="number">0</span>]=dp[i][j][<span class="number">1</span>]=dp[i][j][<span class="number">2</span>]=inf;</span><br><span class="line">    inc(i,<span class="number">1</span>,n)dp[i][<span class="number">1</span>][<span class="number">1</span>]=dp[i][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    ans=inf;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>从前有棵树。<br>找出$K$个点$A_1,A_2,…,A_k$。最小化$\sum_{i=1}^{k-1} dis(a_i,a_{i+1})$ </p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行两个正整数$n$,$k$,表示数的顶点数和需要选出的点个数。</p><p>接下来$n-1$行每行3个非负整数$x$,$y$,$z$，表示从存在一条从$x$到$y$权值为$z$的边</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>一行一个整数，表示最小的距离和。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;p&gt;首先,$\sum_{i=1}^{k-1} dis(a_i,a_{i+1})​$ 最小化 那么对于这$k​$个点的选择可见必然是一个连通子树 
      
    
    </summary>
    
      <category term="dp" scheme="http://yoursite.com/categories/dp/"/>
    
    
      <category term="树形dp" scheme="http://yoursite.com/tags/%E6%A0%91%E5%BD%A2dp/"/>
    
  </entry>
  
  <entry>
    <title>bzoj3124(树形dp)</title>
    <link href="http://yoursite.com/2019/03/09/bzoj3124-%E6%A0%91%E5%BD%A2dp/"/>
    <id>http://yoursite.com/2019/03/09/bzoj3124-树形dp/</id>
    <published>2019-03-08T18:19:17.000Z</published>
    <updated>2019-03-08T18:46:31.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解:"></a>题解:</h2><p>我们考虑找出任意一条直径的两个端点$x$,$y$ 对直径上的节点打上标记 对于其他不在直径上的点$v$ 找到其离的最近的标记点$pos$  我们考虑当前$dis[pos]-dis[x]$与$dis[y]-dis[pos]$的大小关系然后判断$v$是否为分叉直径上的节点 若是则对原标记节点打上标记 最后的答案则为 每条边的权值是否等于分叉直径的条数</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> link(x) for(edge *j=h[x];j;j=j-&gt;next)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inc(i,l,r) for(int i=l;i&lt;=r;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dec(i,r,l) for(int i=r;i&gt;=l;i--)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> t,v;edge*next;&#125;e[MAXN&lt;&lt;<span class="number">1</span>],*h[MAXN],*o=e;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> vul)</span></span>&#123;o-&gt;t=y;o-&gt;v=vul;o-&gt;next=h[x];h[x]=o++;&#125;</span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ll dis[MAXN];<span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;que;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    inc(i,<span class="number">1</span>,n)vis[i]=dis[i]=<span class="number">0</span>;</span><br><span class="line">    que.push(x);vis[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">    <span class="keyword">int</span> y=que.front();que.pop();</span><br><span class="line">    link(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[j-&gt;t])dis[j-&gt;t]=dis[y]+j-&gt;v,vis[j-&gt;t]=<span class="number">1</span>,que.push(j-&gt;t);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pos=x;</span><br><span class="line">    inc(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dis[i]&gt;dis[pos])pos=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> fa[MAXN],p[MAXN];</span><br><span class="line">ll sum[MAXN];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">    fa[x]=pre;</span><br><span class="line">    link(x)&#123;</span><br><span class="line">    <span class="keyword">if</span>(j-&gt;t==pre)<span class="keyword">continue</span>;</span><br><span class="line">    sum[j-&gt;t]=sum[x]+j-&gt;v;</span><br><span class="line">    dfs(j-&gt;t,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    inc(i,<span class="number">1</span>,n)vis[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">    vis[y]=<span class="number">1</span>;y=fa[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> _dfs(<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(vis[x])k=x;<span class="keyword">else</span> k=y;</span><br><span class="line">    p[x]=k;</span><br><span class="line">    link(x)&#123;</span><br><span class="line">    <span class="keyword">if</span>(j-&gt;t==fa[x])<span class="keyword">continue</span>;</span><br><span class="line">    _dfs(j-&gt;t,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> ans[MAXN];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> __dfs(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    link(x)&#123;</span><br><span class="line">    <span class="keyword">if</span>(j-&gt;t==fa[x])<span class="keyword">continue</span>;</span><br><span class="line">    __dfs(j-&gt;t);</span><br><span class="line">    ans[x]+=ans[j-&gt;t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read();</span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">    inc(i,<span class="number">2</span>,n)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z);</span><br><span class="line">    x=bfs(<span class="number">1</span>);y=bfs(x);</span><br><span class="line">    dfs(x,<span class="number">0</span>);work(y);_dfs(x,x);</span><br><span class="line">    ll len=sum[y]-sum[x];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum[y]-sum[x]);</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    inc(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[i])<span class="keyword">continue</span>;</span><br><span class="line">    ll t1=sum[i]-sum[p[i]];</span><br><span class="line">    <span class="keyword">if</span>(sum[p[i]]-sum[x]&gt;sum[y]-sum[p[i]])&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum[p[i]]-sum[x]+t1==len)ans[p[i]]++,cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sum[p[i]]-sum[x]&lt;sum[y]-sum[p[i]])&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum[y]-sum[p[i]]+t1==len)ans[y]++,ans[p[i]]--,cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1==sum[p[i]]-sum[x])cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __dfs(x);</span><br><span class="line">    <span class="keyword">int</span> ans1=<span class="number">0</span>;</span><br><span class="line">    inc(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==x||!vis[i])<span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(ans[i]==cnt)ans1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小Q最近学习了一些图论知识。根据课本，有如下定义。树：无回路且连通的无向图，每条边都有正整数的权值来表示其长度。如果一棵树有$N$个节点，可以证明其有且仅有$N-1$条边。 路径：一棵树上，任意两个节点之间最多有一条简单路径。我们用$dis(a,b)$表示点$a$和点$b$的路径上各边长度之和。称$dis(a,b)$为$a$ ,$b$两个节点间的距离。<br>直径：一棵树上，最长的路径为树的直径。树的直径可能不是唯一的。<br>现在小Q想知道，对于给定的一棵树，其直径的长度是多少，以及有多少条边满足所有的直径都经过该边。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行包含一个整数$N$，表示节点数。<br>接下来$N-1$行，每行三个整数$a$,$ b$,$ c$ ,表示点 $a$和点$b$之间有一条长度为$c$的无向边。 </p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>共两行。第一行一个整数，表示直径的长度。第二行一个整数，表示被所有<br>直径经过的边的数量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解:&quot;&gt;&lt;/a&gt;题解:&lt;/h2&gt;&lt;p&gt;我们考虑找出任意一条直径的两个端点$x$,$y$ 对直径上的节点打上标记 对于其他不在直径上的点$v$ 找到其离的最近的标记点$pos$
      
    
    </summary>
    
      <category term="dp" scheme="http://yoursite.com/categories/dp/"/>
    
    
      <category term="树形dp" scheme="http://yoursite.com/tags/%E6%A0%91%E5%BD%A2dp/"/>
    
  </entry>
  
</feed>
